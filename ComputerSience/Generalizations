NAVIGATION
Generalizations
Congratulations! You've learned five commands commonly used to navigate the filesystem from the command line. What can we generalize so far?

The command line is a text interface for the computer's operating system. To access the command line, we use the terminal.
A filesystem organizes a computer's files and directories into a tree structure. It starts with the root directory. Each parent directory can contain more child directories and files.
From the command line, you can navigate through files and folders on your computer:
pwd outputs the name of the current working directory.
ls lists all files and directories in the working directory.
cd switches you into the directory you specify.
mkdir creates a new directory in the working directory.
touch creates a new file inside the working directory.

---------------------------------------------------------
BASIC GIT WORKFLOW
Generalizations
You have now been introduced to the fundamental Git workflow. You learned a lot! Let's take a moment to generalize:

Git is the industry-standard version control system for web developers
Use Git commands to help keep track of changes made to a project:
git init creates a new Git repository
git status inspects the contents of the working directory and staging area
git add adds files from the working directory to the staging area
git diff shows the difference between the working directory and the staging area
git commit permanently stores file changes from the staging area in the repository
git log shows a list of all previous commits

--------------------------------------------------

CONTROL FLOW
Review
Great job! We covered a ton of material in this lesson and you've increased the number of tools in your Python toolkit by several fold. Let's review what you've learned this lesson:

Boolean expressions are statements that can be either True or False
A boolean variable is a variable that is set to either True or False.
You can create boolean expressions using relational operators:
Equals: ==
Not equals: !=
Greater than: >
Greater than or equal to: >=
Less than: <
Less than or equal to: <=
if statements can be used to create control flow in your code.
else statements can be used to execute code when the conditions of an if statement are not met.
elif statements can be used to build additional checks into your if statements
try and except statements can be used to build error control into your code.
Let's put these skills to the test!

------------------------------------------------------

CREATING AND MODIFYING A LIST IN PYTHON
Review
So far, we have learned

How to create a list
How to create a list of lists using zip
How to add elements to a list using either .append() or +
How to use range to create lists of integers
Let's practice these skills.

---------------------------------------------------

WORKING WITH LISTS IN PYTHON
Review
In this lesson, we learned how to:

Get the length of a list //len(list)
Select subsets of a list (called slicing) //list[ : ]
Count the number of times that an element appears in a list //list.count('i')
Sort a list of items //list.sort() # sorted(list)

----------------------------------------------
LEARN PYTHON: LOOPS
Review
Good job! In this lesson, you learned

how to write a for loop
how to use range in a loop //list(range(2,9,3))
what infinite loops are and how to avoid them //break
how to skip values in a loop //continue
how to write a while loop 
how to make lists with one line
Let's get some more practice with these concepts!


+++++++++++++++++++++++++++++++++
List Comprehensions:
1.Takes an element in words
2.Assigns that element to a variable called word
3.Checks if word[0] == '@', and if so, it adds word to the new list, usernames. If not, nothing happens.
4.Repeats steps 1-3 for all of the strings in words
Note: if we hadn’t done any checking (let's say we had omitted if word[0] == '@'), the new list would be just a copy of words

++++++++++++++++++++++++++++++++++++
More List Comprehensions:
1.Takes a string in usernames
2.Assigns that number to a variable called user
3.Adds " please follow me!" to user
4.Appends that concatenation to the new list called messages
5.Repeats steps 1-4 for all of the strings in usernames


-------------------------------------------------------------

INTRODUCTION TO STRINGS
Review
Great work! I hope you are now starting to see the potential of strings and how they can be used to solve a huge variety of problems.

In this lesson you learned:

A string is a list of characters.
A character can be selected from a string using its index string_name[index]. These indices start at 0.
A 'slice' can be selected from a string. These can be between two indices or can be 
open-ended, selecting all of the string from a point.

Strings can be concatenated to make larger strings.
len() can be used to determine the number of characters in a string.
Strings can be iterated through using for loops.
Iterating through strings opens up a huge potential for applications, especially when combined with conditional statements.
Let's put your new skills to the test!

--------------------------------------------------------------

MODULES: PYTHON
Modules Python Review
You've learned:

what modules are and how they can be useful
how to use a few of the most commonly used Python libraries
what namespaces are and how to avoid polluting your local namespace
how scope works for files in Python

Programmers can do great things if they are not forced to constantly reinvent tools that have already been built. With the power of modules, we can import any code that someone else has shared publicly.

In this article, we covered some of the Python Standard Library, but you can explore all the modules that come packaged with every installation of Python at the Python Standard Library documentation.

This is just the beginning. Using a package manager (like conda or pip3), you can install any modules available on the Python Package Index.

The sky's the limit!
---------------------------------------------------------

STRING METHODS
Review
Excellent work! This lesson has shown you the vast variety of string methods and their power. Whatever the problem you are trying to solve, if you are working with strings then string methods are likely going to be part of the solution.

Over this lesson you've learned:

.upper(), .title(), and .lower() adjust the casing of your string.
.split() takes a string and creates a list of substrings.
.join() takes a list of strings and creates a string.
.strip() cleans off whitespace, or other noise from the beginning and end of a string.
.replace() replaces all instances of a character/string in a string with another character/string.
.find() searches a string for a character/string and returns the index value that character/string is found at.
.format() and f-strings allow you to interpolate a string with variables.
Well I've been stringing you along for long enough, let's get some more practice in!

------------------------------------------------------------------------------
October 8, 2018

CREATING DICTIONARIES
Review
So far we have learned:

How to create a dictionary //names ={}
How to add elements to a dictionary //names[key] = value (if key exist, value of key is a list: names[key].append = value)
How to update elements in a dictionary //names.update({key: value, key: value})
How to use a list comprehension to create a dictionary from two lists

@@@@@@@@@@@@@@@@@@

students = {key:value for key, value in zip(names, heights)}

1.Takes a pair from the zipped list of pairs from names and heights
2.Names the elements in the pair key (the one originally from the names list) and value (the one originally from the heights list)
3.Creates a key : value item in the students dictionary
4.Repeats steps 1-3 for the entire list of pairs

----------------------------------------------------------------------------------
October 8, 2018 (16:55)

USING DICTIONARIES
Review
In this lesson, you've learned how to go through dictionaries and access keys and values in different ways. Specifically you have seen how to:

Use a key to get a value from a dictionary // dictionary(object).get(key, default value if not exist) or dictionary[key]
Check for existence of keys //try-except
Find the length of a dictionary
Remove a key: value pair from a dictionary //dictionary(object).pop(key, default value if not exist) + still return value which matches key
Iterate through keys and values in dictionaries //.keys(), .values(), .items() return view object

-------------------------------------------------------------------------------
October 9,2018 (22:30)

LEARN PYTHON: CLASSES
Review
So far we've covered what a data type actually is in Python. We explored what the functionality of Python's built-in types (also referred to as primitives) are. We learned how to create our own data types using the class keyword.

We explored the relationship between a class and an object — we create objects when we instantiate a class, we find the class when we check the type() of an object. We learned the difference between class variables (the same for all objects of a class) and instance variables (unique for each object).

We learned about how to define an object's functionality with methods. We created multiple objects from the same class, all with similar functionality, but with different internal data. They all had the same methods, but produced different output because they were different instances.

Take a moment to congratulate yourself, object-oriented programming is a complicated concept.

---------------------------------------------------------------------
October 10, 2018 ()

LEARN PYTHON: INHERITANCE AND POLYMORPHISM
Review
In this lesson, we learned more complicated relationships between classes. We learned:

How to create a subclass of an existing class.
How to redefine existing methods of a parent class in a subclass by overriding them.
How to leverage a parent class's methods in the body of a subclass method using the super() function.
How to define a Python exception that inherits from Exception.
How to write programs that are flexible using interfaces and polymorphism.
How to write data types that look and feel like native data types with dunder methods.
These are really complicated concepts! It's a long journey to get to the state of comfortably being able to build class hierarchies that embody the concerns that your software will need to. Give yourself a pat on the back, you earned it!

--------------------------------------------------------------
Nodes Review
Let's take a minute to review what we've covered about nodes in this lesson.

Nodes:

Contain data, which can be a variety of data types
Contain links to other nodes. If a node has no links, or they are all null, you have reached the end of the path you were following.
Can be orphaned if there are no existing links to them

----------------------------------------------------
NODES: PYTHON
Python Nodes Review
We have a few zany characters to keep track of and Python nodes may do just the trick. Let's get started...

------------------------------------------------------

LINKED LISTS: CONCEPTUAL
Linked List Review
Let's take a minute to review what we've covered about linked lists in this lesson.

Linked Lists:

Are comprised of nodes
The nodes contain a link to the next node (and also the previous node for bidirectional linked lists)
Can be unidirectional or bidirectional
Are a basic data structure, and form the basis for many other data structures
Have a single head node, which serves as the first node in the list
Require some maintenance in order to add or remove nodes
The methods we used are an example and depend on the exact use case and/or programming language being used

-------------------------------------------------------
LINKED LISTS: PYTHON
Linked List Review
Congratulations, you have implemented a linked list in Python!

We did this by:

Defining a Node class to hold the values and links between nodes
Implementing a LinkedList class to handle external operations on the list like adding and removing nodes

---------------------------------------------------

Stacks Review
Let's take a minute to review what we've covered about stacks in this lesson.

Stacks:

Contain data nodes
Support three main operations
Push adds data to the top of the stack
Pop removes and provides data from the top of the stack
Peek reveals data on the top of the stack
Implementations include a linked list or array
Can have a limited size
Pushing data onto a full stack results in a stack overflow
Stacks process data Last In, First Out (LIFO)

-----------------------------------------------------
STACKS: PYTHON
Stacks Python Review
Nice work — you've built out a Stack class that can:

add a new item to the top via a push() method
remove an item from the top and returns its value with a pop() method
return the value of the top item using a peek() method
allows a stack instance to maintain an awareness of its size to prevent stack "overflow"
So how does your code stack up against pizza delivery?

----------------------------------------------------------

QUEUES: CONCEPTUAL
Queues Review
Let's take a minute to review what we've covered about queues in this lesson.

Queues:

Contain data nodes
Support three main operations:
Enqueue adds data to the back of the queue
Dequeue removes and provides data from the front of the queue
Peek provides data on the front of the queue
Can be implemented using a linked list or array
Bounded queues have a limited size.
Enqueueing onto a full queue causes a queue overflow
Queues process data First In, First Out (FIFO)

---------------------------------------------------

QUEUES: PYTHON
Queues Python Review
Congrats! You have just implemented a queue data structure in Python by creating a Queue class that:

follows FIFO protocol with enqueue(), dequeue(), and peek() methods
gives you the option of creating bounded queues with a max_size
prevents queue "overflow" and "underflow" by keeping track of size

----------------------------------------------------


HASH MAPS: CONCEPTUAL
Review
We've learned together what a hash map is and how to create one. Let's go over the concepts presented in this lesson.

A hash map is:

Built on top of an array using a special indexing system.
A key-value storage with fast assignments and lookup.
A table that represents a map from a set of keys to a set of values.
Hash maps accomplish all this by using a hash function, which turns a key into an index into the underlying array.

A hash collision is when a hash function returns the same index for two different keys.

There are different hash collision strategies. Two important ones are separate chaining, where each array index points to a different data structure, and open addressing, where a collision triggers a probing sequence to find where to store the value for a given key.

@@@@@@@@@@@@@@@@@@@@@@@@

Hash map: A key-value store that uses an array and a hashing function to save and retrieve values.
Key: The identifier given to a value for later retrieval.
Hash function: A function that takes some input and returns a number.
Compression function: A function that transforms its inputs into some smaller range of possible outputs.

Recipe for saving to a hash table:
- Take the key and plug it into the hash function, getting the hash code.
- Modulo that hash code by the length of the underlying array, getting an array index.
- Check if the array at that index is empty, if so, save the value (and the key) there.
- If the array is full at that index continue to the next possible position depending on your collision strategy.

Recipe for retrieving from a hash table:
- Take the key and plug it into the hash function, getting the hash code.
- Modulo that hash code by the length of the underlying array, getting an array index.
- Check if the array at that index has contents, if so, check the key saved there.
- If the key matches the one you're looking for, return the value.
- If the keys don't match, continue to the next position depending on your collision strategy.

------------------------------------------------------------------------------

HASH MAPS: PYTHON
Review
Now that we have all of the functionality of a Hash Map, it's time to review what we've learned!

-------------------------------------------------
TREES: CONCEPTUAL
Tree Review
Trees are useful for modeling data that has a hierarchical relationship which moves in the direction from parent to child. No child node will have more than one parent.

To recap some terms:

root: A node which has no parent. One per tree.
parent: A node which references other nodes.
child: Nodes referenced by other nodes.
sibling: Nodes which have the same parent.
leaf: Nodes which have no children.
level: The height or depth of the tree. Root nodes are at level 1, their children are at level 2, and so on.

------------------------------------------------------
TREES: PYTHON
Tree Review
Congratulations, you have implemented a tree in Python.

For review, in our implementation:

Trees are a Python class called TreeNode.
A TreeNode has two properties, value and children.
Nodes hold any type of data inside value.
children is a list, which can be empty or hold other instances of TreeNode.
We add to children by using the list method .append.
We remove from children by filtering the list.

---------------------------------------------------------

HEAPS: PYTHON
Min-Heap Review
Nice work! You've implemented a min-heap in Python, and that's no small feat (although it could efficiently track the smallest feat).

To recap: MinHeap tracks the minimum element as the element at index 1 within an internal Python list.

When adding elements, we use .heapify_up() to compare the new element with its parent, making swaps if it violates the heap property: children must be greater than their parents.

When removing the minimum element, we swap it with the last element in the list. Then we use .heapify_down() to compare the new root with its children, swapping with the smaller child if necessary.

Heaps are so useful because they're efficient in maintaining their heap properties. Building a heap using elements that decreased in value would ensure that we continually violated the heap property. How many swaps would that cause?

---------------------------------------------------------------
GRAPHS: CONCEPTUAL

Reviewing Key Terms
Graphs are an essential data structure in computer science for modeling networks. Let's review some key terms:

vertex: A node in a graph.
edge: A connection between two vertices.
adjacent: When an edge exists between vertices.
path: A sequence of one or more edges between vertices.
disconnected: Graph where at least two vertices have no path connecting them.
weighted: Graph where edges have an associated cost.
directed: Graph where travel between vertices can be restricted to a single direction.
cycle: A path which begins and ends at the same vertex.
adjacency matrix: Graph representation where vertices are both the rows and the columns. Each cell represents a possible edge.

--------------------------------------------------------------

GRAPHS: PYTHON
Graph Review
Fantastic work! We've implemented a robust graph data structure in Python. Our two classes, Vertex and Graph are capable of representing the typical variations in graphs that occur in many different algorithms.

Vertex:

Uses a dictionary as an adjacency list to store connected vertices.
Connected vertex names are keys and the edge weights are values.
Has methods to add edges and return a list of connected vertices.
Graph:

Can be initialized as a directed graph, where edges are set in one direction.
Stores every vertex inside a dictionary
Vertex data is the key and the vertex instance is the value.
Has methods to add vertices, edges between vertices, and determine if a path exists between two vertices.
adjacency list: Graph representation where each vertex has a list of all the vertices it shares an edge with.


-----------------------------------------------------------------

BUBBLE SORT: CONCEPTUAL
Bubble Sort Review
Bubble sort is an algorithm to sort a list through repeated swaps of adjacent elements. It has a runtime of O(n^2).

For nearly sorted lists, bubble sort performs relatively few operations since it only performs a swap when elements are out of order.

Bubble sort is a good introductory algorithm which opens the door to learning more complex algorithms. It answers the question, "How can we algorithmically sort a list?" and encourages us to ask, "How can we improve this sorting algorithm?"

===>

Recall that Bubble Sort compares neighboring items and if they are out of order, they are swapped.

-------------------------------------------------------------

MERGE SORT: CONCEPTUAL
Merge Sort Performance
Merge sort was unique for its time in that the best, worst, and average time complexity are all the same: Θ(N*log(N)). This means an almost-sorted list will take the same amount of time as a completely out-of-order list. This is acceptable because the worst-case scenario, where a sort could stand to take the most time, is as fast as a sorting algorithm can be.

Some sorts attempt to improve upon the merge sort by first inspecting the input and looking for "runs" that are already pre-sorted. Timsort is one such algorithm that attempts to use pre-sorted data in a list to the sorting algorithm's advantage. If the data is already sorted, Timsort runs in Θ(N) time.

Merge sort also requires space. Each separation requires a temporary array, and so a merge sort would require enough space to save the whole of the input a second time. This means the worst-case space complexity of merge sort is O(N).

@@@@@@@@@@@@@@@@@@@@@2

This process of "look at the two next-smallest elements of each list and add the smaller one to our resulting list" continues on for as long as both lists have elements to compare. Once one list is exhausted, say every element from left has been added to the result, then we know that all the elements of the other list, right, should go at the end of the resulting list (they're larger than every element we've added so far).

------------------------------------------------------------

MERGE SORT: PYTHON
Testing the Sort
We've written our merge sort! The whole sort takes up two functions:

merge_sort() which is called recursively breaks down an input list to smaller, more manageable pieces. merge() which is a helper function built to help combine those broken-down lists into ordered combination lists.

merge_sort() continues to break down an input list until it only has one element and then it joins that with other single element lists to create sorted 2-element lists. Then it combines 2-element sorted lists into 4-element sorted lists. It continues that way until all the items of the lists are sorted!

Only one thing left to do, test it out!

------------------------------------------------------------
QUICKSORT: CONCEPTUAL
Quicksort Review

Quicksort is an efficient algorithm for sorting values in a list. A single element, the pivot, is chosen from the list. All the remaining values are partitioned into two sub-lists containing the values smaller than and greater than the pivot element.

Ideally, this process of dividing the array will produce sub-lists of nearly equal length, otherwise, the runtime of the algorithm suffers.

When the dividing step returns sub-lists that have one or less elements, each sub-list is sorted. The sub-lists are recombined, or swaps are made in the original array, to produce a sorted list of values.

----------------------------------------------------

QUICKSORT: PYTHON
Quicksort Review
Congratulations on implementing the quicksort algorithm in Python. To review:

We established a base case where the algorithm will complete when the start and end pointers indicate a list with one or zero elements
If we haven't hit the base case, we randomly selected an element as the pivot and swapped it to the end of the list
We then iterate through that list and track all the "lesser than" elements by swapping them with the iteration index and incrementing a lesser_than_pointer.
Once we've iterated through the list, we swap the pivot element with the element located at lesser_than_pointer.
With the list partitioned into two sub-lists, we repeat the process on both halves until base cases are met.

--------------------------------------------

RADIX SORT: CONCEPTUAL
Radix Review
Take a moment to review radix sort:

A radix is the base of a number system. For the decimal number system, the radix is 10.
Radix sort has two variants - MSD and LSD
Numbers are bucketed based on the value of digits moving left to right (for MSD) or right to left (for LSD)
Radix sort is considered a non-comparison sort
The performance of radix sort is O(n)

------------------------------------------

RADIX SORT: PYTHON
Review (and Bug Fix!)
Now that we've finished writing our radix sort we're finished for the day... or are we?

Great job! We created an algorithm that:

Takes numbers in an input list.
Passes through each digit in those numbers, from least to most significant.
Looks at the values of those digits.
Buckets the input list according to those digits.
Renders the results from that bucketing.
Repeats this process until the list is sorted.
And that's what a radix sort does! Feel free to play around with the solution code, see if there's anything you can improve about the code or a different way of writing it you want to try.
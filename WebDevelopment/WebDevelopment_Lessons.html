29/12/2018
INTRODUCTION TO HTML
What is HTML?

<!-- Welcome to the world of code! Last year, millions of learners from our community started with HTML. Why? HTML is the skeleton of all web pages. It's often the first language learned by marketers and designers and is core to front-end development work. If this is your first time touching code, we're excited for what you're about to create.

So what exactly is HTML? HTML provides structure to the content appearing on a website, such as images, text, or videos. Right-click on any page on the internet, choose “Inspect,” and you’ll see HTML in a panel of your screen.

HTML stands for HyperText Markup Language:

A markup language is a computer language that defines the structure and presentation of raw text.
In HTML, the computer can interpret raw text that is wrapped in HTML elements.
HyperText is text displayed on a computer or device that provides access to other text through links, also known as hyperlinks. You probably clicked on a couple of hyperlinks on your way to this Codecademy course.
Learning HTML is the first step in creating websites, but even a bit of knowledge can help you inject code snippets into newsletter, blog or website templates. As you continue learning, you can layer HTML with CSS and JavaScript to create visually compelling and dynamic websites. But for now, we're going to focus on how to add and modify basic content on a page, like text, images, and videos. Don't worry if the websites look ugly — we're just getting started.
 -->
++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
HTML Anatomy

<!-- HTML is composed of elements. These elements structure the webpage and define its content. Let's take a look at how they're written.

The diagram to the right displays an HTML paragraph element. As we can see, the paragraph element is made up of one opening tag (<p>), the content (“Hello World!” text), and a closing tag (</p>). A tag and the content between it is called an HTML element. There are many tags that we can use to organize and display text and other types of content, like images.

Let's quickly review each part of the element pictured:

HTML element (or simply, element) — a unit of content in an HTML document formed by HTML tags and the text or media it contains.

HTML Tag — the element name, surrounded by an opening (<) and closing (>) angle bracket.

Opening Tag — the first HTML tag used to start an HTML element. The tag type is surrounded by opening and closing angle brackets.

Content — The information (text or other elements) contained between the opening and closing tags of an HTML element.

Closing tag — the second HTML tag used to end an HTML element. Closing tags have a forward slash (/) inside of them, directly after the left angle bracket.

Study the diagram to the right to learn about the anatomy of HTML syntax. When you're done, continue to the next exercise.
 -->
++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
The Body

<!-- One of the key HTML elements we use to build a webpage is the body element. Only content inside the opening and closing body tags can be displayed to the screen. Here's what opening and closing body tags look like:

<body>

</body>
Once the file has a body, many different types of content – including text, images, and buttons – can be added to the body.

<body>
   <p>"Life is very short and what we have to do must be done in the now." - Audre Lorde</p>
</body> -->

+++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
HTML Structure

<!-- HTML is organized as a collection of family tree relationships. As you saw in the last exercise, we placed <p> tags within <body> tags. When an element is contained inside another element, it is considered the child of that element. The child element is said to be nested inside of the parent element.

<body>
  <p>This paragraph is a child of the body</p>
</body>
In the example above, the <p> element is nested inside the <body> element. The <p> element is considered a child of the <body> element, and the <body> element is considered the parent. You can also see that we've added two spaces of indentation (using the space bar) for better readability.

Since there can be multiple levels of nesting, this analogy can be extended to grandchildren, great-grandchildren, and beyond. The relationship between elements and their ancestor and descendent elements is known as hierarchy.

Let's consider a more complicated example that uses some new tags:

<body>
  <div>
    <h1>Sibling to p, but also grandchild of body</h1>
    <p>Sibling to h1, but also grandchild of body</p>
  </div>
</body>
In this example, the <body> element is the parent of the <div> element. Both the <h1> and <p> elements are children of the <div> element. Because the <h1> and <p> elements are at the same level, they are considered siblings and are both grandchildren of the <body> element.

Understanding HTML hierarchy is important because child elements can inherit behavior and styling from their parent element. You'll learn more about webpage hierarchy in when you start digging into CSS.
 -->
++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Headings

<!-- Headings in HTML are similar to headings in other types of media. For example, in newspapers, large headings are typically used to capture a reader's attention. Other times, headings are used to describe content, like the title of a movie or an educational article.

HTML follows a similar pattern. In HTML, there are six different headings, or heading elements. Headings can be used for a variety of purposes, like titling sections, articles, or other forms of content.

The following is the list of heading elements available in HTML. They are ordered from largest to smallest in size.

<h1> — used for main headings. All other smaller headings are used for subheadings.
<h2>
<h3>
<h4>
<h5>
<h6>
The following example code uses a headline intended to capture a reader's attention. It uses the largest heading available, the main heading element:

<h1>BREAKING NEWS</h1>
 -->

 <body>
  <h1>The Brown Bear</h1>
  <h2>About Brown Bears</h2>
  <h3>Species</h3>
  <h3>Features</h3>
  <h2>Habitat</h2>
  <h3>Countries with Large Brown Bear Populations</h3>
  <h3>Countries with Small Brown Bear Populations</h3>
  <h2>Media</h2>  
</body>

+++++++++++++++++++++++++++++++++++++

INTRODUCTION TO HTML
Divs

<!-- One of the most popular elements in HTML is the <div> element. <div> is short for "division" or a container that divides the page into sections. These sections are very useful for grouping elements in your HTML together.

<body>
  <div>
    <h1>Why use divs?</h1>
    <p>Great for grouping elements!</p>
  </div>
</body>
<div>s can contain any text or other HTML elements, such as links, images, or videos. Remember to always add two spaces of indentation when you nest elements inside of <div>s for better readability.
 -->
<body>
  <h1>The Brown Bear</h1>
  <div>
    <h2>About Brown Bears</h2>
    <h3>Species</h3>
    <h3>Features</h3>
  </div> 
  <div>
    <h2>Habitat</h2>
    <h3>Countries with Large Brown Bear Populations</h3>
    <h3>Countries with Small Brown Bear Populations</h3>
  </div> 
  <div>
    <h2>Media</h2>
  </div>
</body>

++++++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Attributes

<!-- If we want to expand an element's tag, we can do so using an attribute. Attributes are content added to the opening tag of an element and can be used in several different ways, from providing information to changing styling. Attributes are made up of the following two parts:

The name of the attribute
The value of the attribute
One commonly used attribute is the id. We can use the id attribute to specify different content (such as <div>s) and is really helpful when you use an element more than once. ids have several different purposes in HTML, but for now, we'll focus on how they can help us identify content on our page.

When we add an id to a <div>, we place it in the opening tag:

<div id="intro">
  <h1>Introduction</h1>
</div>
 -->

1.
Add an id attribute with the value "introduction" to the <div> tag that's below the The Brown Bear <h1> heading.

2.
Add an id attribute with the value "habitat" to the opening <div> tag that has the Habitat <h2> heading as a child.

3.
Add an id attribute with the value "media" to the opening <div> tag that has the Media <h2> heading as a child.

+++++++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Displaying Text

<!-- If you want to display text in HTML, you can use a paragraph or span:

Paragraphs (<p>) contain a block of plain text.
<span> contains short pieces of text or other HTML. They are used to separate small pieces of content that are on the same line as other content.
Take a look at each of these elements in action below:

<div>
  <h1>Technology</h1>
</div>
<div>
  <p><span>Self-driving cars</span> are anticipated to replace up to 2 million jobs over the next two decades.</p>
</div>
In the example above, there are two different <div>. The second <div> contains a <p> with <span>Self-driving cars</span>. This <span> element separates "Self-driving cars" from the rest of the text in the paragraph.

It's best to use a <span> element when you want to target a specific piece of content that is inline, or on the same line as other text. If you want to divide your content into blocks, it's better to use a <div>. -->

++++++++++++++++++++++++++++++++++++++++++=
INTRODUCTION TO HTML
Styling Text

<!-- You can also style text using HTML tags. The <em> tag emphasizes text, while the <strong> tag highlights important text.

Later, when you begin to style websites, you will decide how you want browsers to display content within <em> and <strong> tags. Browsers, however, have built-in style sheets that will generally style these tags in the following ways:

The <em> tag will generally render as italic emphasis.
The <strong> will generally render as bold emphasis.
Take a look at each style in action:

<p><strong>The Nile River</strong> is the <em>longest</em> river in the world, measuring over 6,850 kilometers long (approximately 4,260 miles).</p>
In this example, the <strong> and <em> tags are used to emphasize the text to produce the following:

The Nile River is the longest river in the world, measuring over 6,850 kilometers long (approximately 4,260 miles).

As we can see, "The Nile River" is bolded and "longest" is in italics. -->

++++++++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Line Breaks

<!-- The spacing between code in an HTML file doesn't affect the positioning of elements in the browser. If you are interested in modifying the spacing in the browser, you can use HTML's line break element: <br>.

The line break element is unique because it is only composed of a starting tag. You can use it anywhere within your HTML code and a line break will be shown in the browser.

<p>The Nile River is the longest river <br> in the world, measuring over 6,850 <br> kilometers long (approximately 4,260 <br> miles).</p>
The code in the example above will result in an output that looks like the following:

The Nile River is the longest river
in the world, measuring over 6,850
kilometers long (approximately 4,260
miles). -->

+++++++++++++++++++++++++++++++++++++++==
INTRODUCTION TO HTML
Unordered Lists

<!-- In addition to organizing text in paragraph form, you can also display content in an easy-to-read list.

In HTML, you can use an unordered list tag (<ul>) to create a list of items in no particular order. An unordered list outlines individual list items with a bullet point.

The <ul> element should not hold raw text and won't automatically format raw text into an unordered list of items. Individual list items must be added to the unordered list using the <li> tag. The <li> or list item tag is used to describe an item in a list.

<ul>
  <li>Limes</li>
  <li>Tortillas</li>
  <li>Chicken</li>
</ul>
In the example above, the list was created using the <ul> tag and all individual list items were added using <li> tags.

The output will look like this:

*Limes
*Tortillas
*Chicken -->

++++++++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Ordered Lists

<!-- Ordered lists (<ol>) are like unordered lists, except that each list item is numbered. They are useful when you need to list different steps in a process or rank items for first to last.

You can create the ordered list with the <ol> tag and then add individual list items to the list using <li> tags.

<ol>
  <li>Preheat the oven to 350 degrees.</li>
  <li>Mix whole wheat flour, baking soda, and salt.</li>
  <li>Cream the butter, sugar in separate bowl.</li>
  <li>Add eggs and vanilla extract to bowl.</li>
</ol>
The output will look like this:

1.Preheat the oven to 350 degrees.
2.Mix whole wheat flour, baking soda, and salt.
3.Cream the butter, sugar in separate bowl.
4.Add eggs and vanilla extract to bowl. -->

+++++++++++++++++++++++++++++++++++++++++++

INTRODUCTION TO HTML
Images

<!-- All of the elements you've learned about so far (headings, paragraphs, lists, and spans) share one thing in common: they're composed entirely of text! What if you want to add content to your web page that isn't composed of text, like images?

The <img> tag allows you to add an image to a web page. Most elements require both opening and closing tags, but the <img> tag is a self-closing tag. Note that the end of the <img> tag has a forward slash /. Self-closing tags may include or omit the final slash — both will render properly.

<img src="image-location.jpg" />
The <img> tag has a required attribute called src. The src attribute must be set to the image's source, or the location of the image. In this case, the value of src must be the uniform resource locator (URL) of the image. A URL is the web address or local address where a file is stored. -->

+++++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Image Alts

<!-- Part of being an exceptional web developer is making your site accessible to users of all backgrounds. In order to make the Web more inclusive, we need to consider what happens when assistive technologies such as screen readers come across image tags.

The alt attribute, which means alternative text, brings meaning to the images on our sites. The alt attribute can be added to the image tag just like the src attribute. The value of alt should be a description of the image.

<img src="#" alt="A field of yellow sunflowers" />
The alt attribute also serves the following purposes:

If an image fails to load on a web page, a user can mouse over the area originally intended for the image and read a brief description of the image. This is made possible by the description you provide in the alt attribute.
Visually impaired users often browse the web with the aid of screen reading software. When you include the alt attribute, the screen reading software can read the image's description out loud to the visually impaired user.
The alt attribute also plays a role in Search Engine Optimization (SEO), because search engines cannot "see" the images on websites as they crawl the internet. Having descriptive alt attributes can improve the ranking of your site.
If the image on the web page is not one that conveys any meaningful information to a user (visually impaired or otherwise), the alt attribute should be left empty. -->

++++++++++++++++++++++++++++++++++++++
INTRODUCTION TO HTML
Videos

<!-- In addition to images, HTML also supports displaying videos. Like the <img> tag, the <video> tag requires a src attribute with a link to the video source. Unlike the <img> tag however, the <video> element requires an opening and a closing tag.

<video src="myVideo.mp4" width="320" height="240" controls>
  Video not supported
</video>
In this example, the video source (src) is myVideo.mp4 The source can be a video file that is hosted alongside your webpage, or a URL that points to a video file hosted on another webpage.

After the src attribute, the width and height attributes are used to set the size of the video displayed in the browser. The controls attribute instructs the browser to include basic video controls: pause, play and skip.

The text, "Video not supported", between the opening and closing video tags will only be displayed if the browser is unable to load the video. -->

<body>
  <h1>The Brown Bear</h1>
  <div id="introduction">
    <h2>About Brown Bears</h2>
    <p>The brown bear (<em>Ursus arctos</em>) is native to parts of northern Eurasia and North America. Its conservation status is currently <strong>Least Concern</strong>.<br /><br /> There are many subspecies within the brown bear species, including the Atlas bear and the Himalayan brown bear.</p>
    <h3>Species</h3>
    <ul>
      <li>Arctos</li>
      <li>Collarus</li>
      <li>Horribilis</li>
      <li>Nelsoni (extinct)</li>
    </ul>
    <h3>Features</h3>
    <p>Brown bears are not always completely brown. Some can be reddish or yellowish. They have very large, curved claws and huge paws. Male brown bears are often 30% larger than female brown bears. They can range from 5 feet to 9 feet from head to toe.</p>
  </div>
  <div id="habitat">
    <h2>Habitat</h2>
    <h3>Countries with Large Brown Bear Populations</h3>
    <ol>
      <li>Russia</li>
      <li>United States</li>
      <li>Canada</li>
    </ol>
    <h3>Countries with Small Brown Bear Populations</h3>
    <p>Some countries with smaller brown bear populations include Armenia, Belarus, Bulgaria, China, Finland, France, Greece, India, Japan, Nepal, Poland, Romania, Slovenia, Turkmenistan, and Uzbekistan.</p>
  </div>
  <div id="media">
    <h2>Media</h2>
    <img src="https://s3.amazonaws.com/codecademy-content/courses/web-101/web101-image_brownbear.jpg" alt="A Brown Bear"/>
        <video src="https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-1/lesson-2/htmlcss1-vid_brown-bear.mp4" width="320" height="240" controls>Video not supported</video>
  </div>
</body>

-----------------------------------------------
29/12/2018

HTML DOCUMENT STANDARDS
Preparing for HTML

<!-- Now that you've learned about some of the most common HTML elements, it's time to learn how to set up an HTML file.

HTML files require certain elements to set up the document properly. You can let web browsers know that you are using HTML by starting your document with a document type declaration.

The declaration looks like this:

<!DOCTYPE html>
This declaration is an instruction, and it must be the first line of code in your HTML document. It tells the browser what type of document to expect, along with what version of HTML is being used in the document. For now, the browser will correctly assume that the html in <!DOCTYPE html> is referring to HTML5, as it is the current standard.

In the future, however, a new standard will override HTML5. To make sure your document is forever interpreted correctly, always include <!DOCTYPE html> at the very beginning of your HTML documents.

Lastly, HTML code is always saved in a file with an .html extension. -->

+++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
The <html> tag

<!-- The <!DOCTYPE html> declaration provides the browser with two pieces of information (the type of document and the HTML version to expect), but it doesn't actually add any HTML structure or content.

To create HTML structure and content, we must add opening and closing <html> tags after declaring <!DOCTYPE html>:

<!DOCTYPE html>
<html>

</html>
Anything between the opening <html> and closing </html> tags will be interpreted as HTML code. Without these tags, it's possible that browsers could incorrectly interpret your HTML code. -->

++++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
The Head

<!-- So far you've done two things to set up the file properly:

Declared to the browser that your code is HTML with <!DOCTYPE html>
Added the HTML element (<html>) that will contain the rest of your code.
We have added these elements to the Brown Bears page you previously created. Now, let's also give the browser some information about the page itself. We can do this by adding a <head> element.

Remember the <body> tag? The <head> element is part of this HTML metaphor. It goes above our <body> element.

The <head> element contains the metadata for a web page. Metadata is information about the page that isn't displayed directly on the web page. Unlike the information inside of the <body> tag, the metadata in the head is information about the page itself. You'll see an example of this in the next exercise.

The opening and closing head tags typically appear as the first item after your first HTML tag:

<head>
</head> -->

++++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Page Titles

<!-- What kind of metadata about the web page can the <head> element contain?

If you navigate to the Codecademy catalog and look at the top of your browser, you'll notice the words Catalog | Codecademy, which is the title of the web page.

A browser's tab displays the title specified in the <title> tag. The <title> tag is always inside of the <head>.

<!DOCTYPE html>
<html>
  <head>
    <title>My Coding Journal</title>
  </head>
</html>
If we were to open a file containing the HTML code in the example above, the browser would display the words My Coding Journal in the title bar (or in the tab's title). -->

++++++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Where Does the Title Appear?

<!-- Good work! Unfortunately, the browser panel used by the Codecademy environment does not have a title bar, so the "Brown Bear" title you wrote in the previous exercise will not be displayed. Outside of the Codecademy environment, however, your title would appear as depicted in the diagram to the right.

So far, we have learned about:

<!DOCTYPE html>, the declaration specifying the version of HTML for the browser
The <html> tags that enclose all of your HTML code
The <head> tag that contains the metadata of a webpage, such as its <title>
Next, you will learn about new types of elements that go inside the body. -->

++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Linking to Other Web Pages

<!-- One of the powerful aspects of HTML (and the Internet), is the ability to link to other web pages.

You can add links to a web page by adding an anchor element <a> and including the text of the link in between the opening and closing tags.

<a>This Is A Link To Wikipedia</a>
Wait a minute! Technically, the link in the example above is incomplete. How exactly is the link above supposed to work if there is no URL that will lead users to the actual Wikipedia page?

The anchor element in the example above is incomplete without the href attribute. This attribute stands for hyperlink reference and is used to link to a path, or the address to where a file is located (whether it is on your computer or another location). The paths provided to the href attribute are often URLs.

<a href="https://www.wikipedia.org/">This Is A Link To Wikipedia</a>
In the example above, the href attribute has been set to the value of the URL https://www.wikipedia.org/. The example now shows the correct use of an anchor element.

When reading technical documentation, you may come across the term hyperlink. Not to worry, this is simply the technical term for link. These terms are often used interchangeably. -->

++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Opening Links in a New Window

<!-- Have you ever clicked on a link and observed the resulting web page open in a new browser window? If so, you can thank the <a> element's target attribute.

The target attribute specifies how a link should open.

It's possible that one or more links on your web page link to an entirely different website. In that case, you may want users to read the linked website, but hope that they return to your web page. This is exactly when the target attribute is useful!

For a link to open in a new window, the target attribute requires a value of _blank. The target attribute can be added directly to the opening tag of the anchor element, just like the href attribute.

<a href="https://en.wikipedia.org/wiki/Brown_bear" target="_blank">The Brown Bear</a>
In the example above, setting the target attribute to "_blank" instructs the browser to open the relevant Wikipedia page in a new window.

In this exercise, we've used the terminology "open in a new window." It's likely that you are using a modern browser that opens up websites in new tabs, rather than new windows. Before the advent of browsers with tabs, additional browser windows had to be opened to view more websites. The target="_blank" attribute, when used in modern browsers, will open new websites in a new tab. -->

+++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Linking to Relative Page

<!-- Thus far you have learned how to link to external web pages. Many sites also link to internal web pages like Home, About, and Contact.

Before we learn how to link between internal pages, let's establish where our files are stored. When making multi-page static websites, web developers often store HTML files in the root directory, or a main folder where all the files for the project are stored. As the size of the projects you create grows, you may use additional folders within the main project folder to organize your code.

project-folder/
|—— about.html
|—— contact.html
|—— index.html
The example above shows three different files — about.html, contact.html, and index.html in one folder.

HTML files are often stored in the same folder, as shown in the example above. If the browser is currently displaying index.html, it also knows that about.html and contact.html are in the same folder. Because the files are stored in the same folder, we can link web pages together using a relative path.

<a href="./contact.html">Contact</a>
In this example, the <a> tag is used with a relative path to link from the current HTML file to the contact.html file in the same folder. On the web page, Contact will appear as a link.

A relative path is a filename that shows the path to a local file (a file on the same website, such as ./index.html) versus an absolute path (a full URL, like https://www.codecademy.com/learn/learn-html which is stored in a different folder). The ./ in ./index.html tells the browser to look for the file in the current folder. -->

+++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Linking At Will

<!-- You've probably visited websites where not all links were made up of text. Maybe the links you clicked on were images or some other form of content.

So far, we've added links that were made up of only text, like the following:

<a href="https://en.wikipedia.org/wiki/Opuntia" target="_blank">Prickly Pear</a>
Text-only links, however, would significantly decrease your flexibility as a web developer!

Thankfully, HTML allows you to turn nearly any element into a link by wrapping that element with an anchor element. With this technique, it's possible to turn images into links by simply wrapping the <img> element with an <a> element.

<a href="https://en.wikipedia.org/wiki/Opuntia" target="_blank"><img src="#" alt="A red prickly pear fruit"/></a>
In the example above, an image of a prickly pear has been turned into a link by wrapping the outside of the <img> element with an <a> element. -->

+++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Linking to Same Page

<!-- At this point, we have all the content we want on our page. Since we have so much content, it doesn't all fit on the screen. How do we make it easier for a user to jump to different portions of our page?

When users visit our site, we want them to be able to click a link and have the page automatically scroll to a specific section.

In order to link to a target on the same page, we must give the target an id, like this:

<p id="top">This is the top of the page!</p>
<h1 id="bottom">This is the bottom! </h1>
In this example, the <p> element is assigned an id of "top" and the <h1> element is assigned "bottom." An id can be added to most elements on a webpage.

An id should be descriptive to make it easier to remember the purpose of a link. The target link is a string containing the # character and the target element's id.

<ol>
  <li><a href="#top">Top</a></li>
  <li><a href="#bottom">Bottom</a></li>
</ol>
In the example above, the links to <p id="top"> and <h1 id="bottom"> are embedded in an ordered list. These links appear in the browser as a numbered list of links. An id is especially helpful for organizing content belonging to a div!	 -->

+++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Whitespace

<!-- The rest of this lesson will focus on some tools developers use to make code easier to interpret.

As the code in an HTML file grows, it becomes increasingly difficult to keep track of how elements are related. Programmers use two tools to visualize the relationship between elements: whitespace and indentation.

Both tools take advantage of the fact that the position of elements in a browser is independent of the amount of whitespace or indentation in the index.html file.

For example, if you wanted to increase the space between two paragraphs on your web page, you would not be able to accomplish this by adding space between the paragraph elements in the index.html file. The browser ignores whitespace in HTML files when it renders a web page, so it can be used as a tool to make code easier to read and follow.

What makes the example below difficult to read?

<body><p>Paragraph 1</p><p>Paragraph 2</p></body>
You have to read the entire line to know what elements are present. Compare the example above to this:

<body>
    <p>Paragraph 1</p>
    <p>Paragraph 2</p>
</body>
This example is easier to read, because each element is on its own line. While the first example required you to read the entire line of code to identify the elements, this example makes it easy to identify the body tag and two paragraphs.

A browser renders both examples the same way:

Paragraph 1
Paragraph 2
In the next exercise you will learn how to use indentation to help visualize nested elements.	 -->

++++++++++++++++++++++++++++++++++++++++++
HTML DOCUMENT STANDARDS
Indentation

<!-- The second tool web developers use to make the structure of code easier to read is indentation. The spaces are inserted using the space and tab bars on your keyboard.

The World Wide Web Consortium, or W3C, is responsible for maintaining the style standards of HTML. At the time of writing, the W3C recommends 2 spaces of indentation when writing HTML code. Although your code will work without exactly two spaces, this standard is followed by the majority of professional web developers. Indentation is used to easily visualize which elements are nested within other elements.

<body>
  <p>Paragraph 1</p>
  <div>
    <p>Paragraph 2</p>
  </div>
</body>
In the example above, Paragraph 1 and the <div> tag are nested inside of the <body> tag, so they are indented two spaces. The Paragraph 2 element is nested inside of the <div> tag, so it is indented an additional two spaces. -->

+++++++++++++++++++++++++++++++++++++++

HTML DOCUMENT STANDARDS
Comments

<!-- HTML files also allow you to add comments to your code.

Comments begin with and end with. Any characters in between will be ignored by your browser.

This is a comment that the browser will not display.
Including comments in your code is helpful for many reasons:

They help you (and others) understand your code if you decide to come back and review it at a much later date.
They allow you to experiment with new code, without having to delete old code.
Favorite Films Section
<p>The following is a list of my favorite films:</p>
In this example, the comment is used to denote that the following text makes up a particular section of the page.

<p> Test Code </p>
In the example above, a valid HTML element (a paragraph element) has been "commented out." This practice is useful when there is code you want to experiment with, or return to, in the future.	 -->

<!DOCTYPE html>
<html>

<head>
  <title>Brown Bears</title>
</head>

<body>
  <nav>
    <a href="./index.html">Brown Bear</a>
    <a href="./aboutme.html">About Me</a>
  </nav>
  <h1>The Brown Bear</h1>
  <nav>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#habitat">Habitat</a></li>
      <li><a href="#media">Media</a></li>
    </ul>
  </nav>
  <div id="introduction">
    <h2>About Brown Bears</h2>
    <p>The brown bear (<em>Ursus arctos</em>) is native to parts of northern Eurasia and North America. Its conservation status is currently <strong>Least Concern</strong>.<br /><br /> There are many subspecies within the brown bear species, including the
      Atlas bear and the Himalayan brown bear.</p>
    <a href="https://en.wikipedia.org/wiki/Brown_bear" target="_blank">Learn More</a>
    <h3>Species</h3>
    <ul>
      <li>Arctos</li>
      <li>Collarus</li>
      <li>Horribilis</li>
      <li>Nelsoni (extinct)</li>
    </ul>
    <h3>Features</h3>
    <p>Brown bears are not always completely brown. Some can be reddish or yellowish. They have very large, curved claws and huge paws. Male brown bears are often 30% larger than female brown bears. They can range from 5 feet to 9 feet from head to toe.</p>
  </div>
  <div id="habitat">
    <h2>Habitat</h2>
    <h3>Countries with Large Brown Bear Populations</h3>
    <ol>
      <li>Russia</li>
      <li>United States</li>
      <li>Canada</li>
    </ol>
    <h3>Countries with Small Brown Bear Populations</h3>
    <p>Some countries with smaller brown bear populations include Armenia, Belarus, Bulgaria, China, Finland, France, Greece, India, Japan, Nepal, Poland, Romania, Slovenia, Turkmenistan, and Uzbekistan.</p>
  </div>
  <div id="media">
    <h2>Media</h2>
    <img src="https://s3.amazonaws.com/codecademy-content/courses/web-101/web101-image_brownbear.jpg" />
    <video src="https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-1/lesson-2/htmlcss1-vid_brown-bear.mp4" height="240" width="320" controls>Video not supported</video>
  </div>
</body>

</html>

----------------------------------------------------------------------------------
30/12/2018

TABLES
Why Tables?

<!-- There are many websites on the Internet that display information like stock prices, sports scores, invoice data, and more. This data is naturally tabular in nature, meaning that a table is often the best way of presenting the data.

In this part of the course, you'll learn how to use HTML to present tabular data to users.

Let's begin! -->

++++++++++++++++++++++++++
TABLES
Create a Table

<!-- Before displaying data, you must first create the table that will contain the data by using the <table> element.

<table>

</table>
The <table> element will contain all of the tabular data you plan on displaying. -->

+++++++++++++++++++++++++++++
TABLES
Table Rows

<!-- In many programs that use tables, the table is already predefined for you, meaning that it contains the rows, columns, and cells that will hold data. In HTML, all of these components must be created.

The first step in entering data into the table is to add rows using the table row element: <tr>.

<table>
  <tr>
  </tr>
  <tr>
  </tr>
</table>
In the example above, two rows have been added to the table.	 -->

++++++++++++++++++++++++++++++++++
TABLES
Table Data

<!-- 
Rows aren't sufficient to add data to a table. Each cell element must also be defined. In HTML, you can add data using the table data element: <td>.

<table>
  <tr>
    <td>73</td>
    <td>81</td>
  </tr>
</table>
In the example above, two data points (73 and 81) were entered in the one row that exists. By adding two data points, we created two cells of data.

If the table were displayed in the browser, it would show a table with one row and two columns. -->

++++++++++++++++++++++++++++++++++
TABLES
Table Headings

<!-- Table data doesn't make much sense without titles to describe what the data represents.

To add titles to rows and columns, you can use the table heading element: <th>.

The table heading element is used just like a table data element, except with a relevant title. Just like table data, a table heading must be placed within a table row.

<table>
  <tr>
    <th></th>
    <th scope="col">Saturday</th>
    <th scope="col">Sunday</th>
  </tr>
  <tr>
    <th scope="row">Temperature</th>
    <td>73</td>
    <td>81</td>
  </tr>
</table>
What happened in the code above?

First, a new row was added to hold the three headings: a blank heading, a Saturday heading, and a Sunday heading. The blank heading creates the extra table cell necessary to align the table headings correctly over the data they correspond to.

In the second row, one table heading was added as a row title: Temperature.

Note, also, the use of the scope attribute, which can take one of two values:

row - this value makes it clear that the heading is for a row.
col - this value makes it clear that the heading is for a column.
HTML code for tables may look a little strange at first, but analyzing it piece by piece helps make the code more understandable. -->

++++++++++++++++++++++++++++++++++++++

TABLES
Table Borders

<!-- So far, the tables you've created have been a little difficult to read because they have no borders.

In older versions of HTML, a border could be added to a table using the border attribute and setting it equal to an integer. This integer would represent the thickness of the border.

<table border="1">
  <tr>
    <td>73</td>
    <td>81</td>
  </tr>
</table>
The code in the example above is following is deprecated, so please don't use it. It's meant to illustrate older conventions you may come across when reading other developers' code.

The browser will likely still interpret your code correct if you use the border attribute, but that doesn't mean the attribute should be used. Instead, you can achieve the same effect using CSS.

table, td {
  border: 1px solid black;
}
The code in the example above uses CSS instead of HTML to show table borders. -->

+++++++++++++++++++++++++++++++++

TABLES
Spanning Columns

<!-- What if the table contains data that spans multiple columns?

For example, a personal calendar could have events that span across multiple hours, or even multiple days.

Data can span columns using the colspan attribute. The attributes accepts an integer (greater than or equal to 1) to denote the number of columns it spans across.

<table>
  <tr>
    <th>Monday</th>
    <th>Tuesday</th>
    <th>Wednesday</th>
  </tr>
  <tr>
    <td colspan="2">Out of Town</td>
    <td>Back in Town</td>
  </tr>
</table>
In the example above, the data Out of Town spans the Monday and Tuesday table headings using the value 2 (two columns). The data Back in Town appear only under the Wednesday heading. -->

++++++++++++++++++++++++++++++++++++++++
TABLES
Spanning Rows

<!-- 
Data can also span multiple rows using the rowspan attribute.

The rowspan attribute is used for data that spans multiple rows (perhaps an event goes on for multiple hours on a certain day). It accepts an integer (greater than or equal to 1) to denote the number of rows it spans across.

<table>
  <tr> Row 1
    <th></th>
    <th>Saturday</th>
    <th>Sunday</th>
  </tr>
  <tr> Row 2
    <th>Morning</th>
    <td rowspan="2">Work</td>
    <td rowspan="3">Relax</td>
  </tr>
  <tr> Row 3
    <th>Afternoon</th>
  </tr>
  <tr> Row 4
    <th>Evening</th>
    <td>Dinner</td>
  </tr>
</table>
In the example above, there are four rows:

The first row contains an empty cell and the two column headings.
The second row contains the Morning row heading, along with Work, which spans two rows under the Saturday column. The "Relax" entry spans three rows under the Sunday column.
The third row only contains the Afternoon row heading.
The fourth row only contains the Dinner entry, since "Relax" spans into the cell next to it.
If you'd like to see how the browser interprets the code above, feel free to copy and paste it into the code editor to understand it a little better. -->

+++++++++++++++++++++++++++++
TABLES
Table Body

<!-- Over time, a table can grow to contain a lot of data and become very long. When this happens, the table can be sectioned off so that it is easier to manage.

Long tables can be sectioned off using the table body element: <tbody>.

The <tbody> element should contain all of the table's data, excluding the table headings (more on this in a later exercise).

<table>
  <tbody>
    <tr>
      <th></th>
      <th>Saturday</th>
      <th>Sunday</th>
    </tr>
    <tr>
      <th>Morning</th>
      <td rowspan="2">Work</td>
      <td rowspan="3">Relax</td>
    </tr>
    <tr>
     <th>Afternoon</th>
    </tr>
    <tr>
      <th>Evening</th>
      <td>Dinner</td>
    </tr>
  </tbody>
</table>
In the example above, all of the table data is contained within a table body element. Note, however, that the headings were also kept in the table's body — we'll change this in the next exercise. -->

++++++++++++++++++++++++++++++++++++
TABLES
Table Head

<!-- In the last exercise, the table's headings were kept inside of the table's body. When a table's body is sectioned off, however, it also makes sense to section off the table's headings using the <thead> element.

<table>
  <thead>
    <tr>
      <th></th>
      <th>Saturday</th>
      <th>Sunday</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Morning</th>
      <td rowspan="2">Work</td>
      <td rowspan="3">Relax</td>
    </tr>
    <tr>
     <th>Afternoon</th>
    </tr>
    <tr>
      <th>Evening</th>
      <td>Dinner</td>
    </tr>
  </tbody>
</table>
In the example above, the only new element is <thead>. The table headings are contained inside of this element. Note that the table's head still requires a row in order to contain the table headings. -->

++++++++++++++++++++++++++++++++++++
TABLES
Table Footer

<!-- The bottom part of a long table can also be sectioned off using the <tfoot> element.

<table>
  <thead>
    <tr>
      <th>Quarter</th>
      <th>Revenue</th>
      <th>Costs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Q1</th>
      <td>$10M</td>
      <td>$7.5M</td>
    </tr>
    <tr>
      <th>Q2</th>
      <td>$12M</td>
      <td>$5M</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <th>Total</th>
      <td>$22M</td>
      <td>$12.5M</td>
    </tr>
  </tfoot>
</table>
In the example above, the footer contains the totals of the data in the table. Footers are often used to contain sums, differences, and other data results.	 -->

+++++++++++++++++++++++++++++
TABLES
Styling with CSS

<!-- Tables, by default, are very bland. They have no borders, the font color is black, and the typeface is the same type used for other HTML elements.

You can use CSS to style tables just like you have done in the past. Specifically, you can change style the various aspects mentioned above.

table, th, td {
  border: 1px solid black;
  font-family: Arial, sans-serif;
  text-align: center;
}
The code in the example above demonstrates just some of the various table aspects you can style using the CSS properties you learned about earlier. -->

+++++++++++++++++++++++++++++++++
TABLES
HTML Tables

<!DOCTYPE html>
<html>
<head>
  <title>Ship To It - Company Packing List</title>
  <link href="https://fonts.googleapis.com/css?family=Lato: 100,300,400,700|Luckiest+Guy|Oxygen:300,400" rel="stylesheet">
  <link href="style.css" type="text/css" rel="stylesheet">
</head>
<body>

  <ul class="navigation">
    <li><img src="https://s3.amazonaws.com/codecademy-content/courses/web-101/unit-9/htmlcss1-img_logo-shiptoit.png" height="20px;"></li>
    <li class="active">Action List</li>
    <li>Profiles</li>
    <li>Settings</li>
  </ul>

  <div class="search">Search the table</div>
  
  <table>
    <thead>
      <tr>
        <th>Company Name</th>
        <th>Number of Items to Ship</th>
        <th>Next Action</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Adam's Greenworks</td>
        <td>14</td>
        <td>Package Items</td>
      </tr>
      <tr>
        <td>Davie's Burgers</td>
        <td>2</td>
        <td>Send Invoice</td>
      </tr>
      <tr>
        <td>Baker's Bike Shop</td>
        <td>3</td>
        <td>Send Invoice</td>
      </tr>
      <tr>
        <td>Miss Sally's Southern</td>
        <td>4</td>
        <td>Ship</td>
      </tr>
      <tr>
        <td>Summit Resort Rentals</td>
        <td>4</td>
        <td>Ship</td>
      </tr>
      <tr>
        <td>Strike Fitness</td>
        <td>1</td>
        <td>Enter Order</td>
      </tr>
    </tbody>
    <tfoot>
      <td>Total</td>
			<td>28</td>
    </tfoot>
  </table>
</body>
</html>

-----------------------------------------------------------------------
31/12/2018

CSS SETUP AND SELECTORS
Inline Styles

<!-- Although CSS is a different language than HTML, it's possible to write CSS code directly within HTML code using inline styles.

To style an HTML element, you can add the style attribute directly to the opening tag. After you add the attribute, you can set it equal to the CSS style(s) you'd like applied to that element.

<p style="color: red;">I'm learning to code!</p>
The code in the example above demonstrates how to use inline styling. The paragraph element has a style attribute within its opening tag. Next, the style attribute is set equal to color: red;, which will set the color of the paragraph text to red within the browser.

You might be wondering about the syntax of the following snippet of code: color: red;. At the moment, the details of the syntax are not important; you'll learn more about CSS syntax in other exercises. For now, it's important to know that inline styles are a quick way of directly styling an HTML element.

If you'd like to add more than one style with inline styles, simply keep adding to the style attribute. Make sure to end the styles with a semicolon (;).

<p style="color: red; font-size: 20px;">I'm learning to code!</p>
 -->

 +++++++++++++++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
<!-- The <style> Tag

Inline styles are a fast way of styling HTML, but they also have limitations. If you wanted to style, for example, multiple <h1> elements, you would have to add inline styling to each element manually. In addition, you would also have to maintain the HTML code when additional <h1> elements are added.

Fortunately, HTML allows you to write CSS code in its own dedicated section with the <style> element. CSS can be written between opening and closing <style> tags. To use the <style> element, it must be placed inside of the <head> element.

<head>
  <style>
  </style>
</head>
After adding a <style> tag in the head section, you can begin writing CSS code.

<head>
  <style>
    p {
      color: red;
      font-size: 20px;
    }
  </style>
</head>
The CSS code in the example above changes the color of all paragraph text to red and also changes the size of the text to 20 pixels. Note how the syntax of the CSS code matches (for the most part) the syntax you used for inline styling. The main difference is that you can specify which elements to apply the styling to.

Again, the details of the CSS syntax in the example above aren't important at the moment. You will learn more about the details of CSS syntax in later lessons. -->

 ++++++++++++++++++++++++++++++++++++++++
 CSS SETUP AND SELECTORS
The .css file

<!-- Developers avoid mixing code by storing HTML and CSS code in separate files (HTML files contain only HTML code, and CSS files contain only CSS code).

You can create a CSS file by using the .css file name extension, like so: style.css

With a CSS file, you can write all the CSS code needed to style a page without sacrificing the readability and maintainability of your HTML file. -->

++++++++++++++++++++++++++++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Linking the CSS File

<!-- Perfect! We successfully separated structure (HTML) from styling (CSS), but the web page still looks bland. Why?

When HTML and CSS code are in separate files, the files must be linked. Otherwise, the HTML file won't be able to locate the CSS code, and the styling will not be applied.

You can use the <link> element to link HTML and CSS files together. The <link> element must be placed within the head of the HTML file. It is a self-closing tag and requires the following three attributes:

href — like the anchor element, the value of this attribute must be the address, or path, to the CSS file.
type — this attribute describes the type of document that you are linking to (in this case, a CSS file). The value of this attribute should be set to text/css.
rel — this attribute describes the relationship between the HTML file and the CSS file. Because you are linking to a stylesheet, the value should be set to stylesheet.
When linking an HTML file and a CSS file together, the <link> element will look like the following:

<link href="https://www.codecademy.com/stylesheets/style.css" type="text/css" rel="stylesheet">
Note that in the example above the path to the stylesheet is a URL:

https://www.codecademy.com/stylesheets/style.css
Specifying the path to the stylesheet using a URL is one way of linking a stylesheet.

If the CSS file is stored in the same directory as your HTML file, then you can specify a relative path instead of a URL, like so:

<link href="./style.css" type="text/css" rel="stylesheet">
Using a relative path is very common way of linking a stylesheet. -->

+++++++++++++++++++++++++++++

CSS SETUP AND SELECTORS
Tag Name

<!-- CSS can select HTML elements by using an element's tag name. A tag name is the word (or character) between HTML angle brackets.

For example, in HTML, the tag for a paragraph element is <p>. The CSS syntax for selecting <p> elements is:

p {

}
In the example above, all paragraph elements will be selected using a CSS selector. The selector in the example above is p. Note that the CSS selector matches the HTML tag for that element, but without the angle brackets.

In addition, two curly braces follow immediately after the selector (an opening and closing brace, respectively). Any CSS properties will go inside of the curly braces to style the selected elements. -->

+++++++++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Class Name

<!-- CSS is not limited to selecting elements by tag name. HTML elements can have more than just a tag name; they can also have attributes. One common attribute is the class attribute. It's also possible to select an element by its class attribute.

For example, consider the following HTML:

<p class="brand">Sole Shoe Company</p>
The paragraph element in the example above has a class attribute within the <p> tag. The class attribute is set to "brand". To select this element using CSS, we could use the following CSS selector:

.brand {

}
To select an HTML element by its class using CSS, a period (.) must be prepended to the class's name. In the example above case, the class is brand, so the CSS selector for it is .brand. -->

++++++++++++++++++++++++++++++++++

CSS SETUP AND SELECTORS
Multiple Classes

<!-- We can use CSS to select an HTML element's class attribute by name.

So far, we've selected elements using only one class name per element. If every HTML element had a single class, all the style information for each element would require a new class.

Luckily, it's possible to add more than one class name to an HTML element's class attribute.

For instance, perhaps there's a heading element that needs to be green and bold. You could write two CSS rules like so:

.green {
  color: green;
}

.bold {
  font-weight: bold;
}
Then, you could include both of these classes on one HTML element like this:

<h1 class="green bold"> ... </h1>
We can add multiple classes to an HTML element's class attribute by separating them with a space. This enables us to mix and match CSS classes to create many unique styles without writing a custom class for every style combination needed. -->

+++++++++++++++++++++++++++++++++

CSS SETUP AND SELECTORS
ID Name

<!-- 
If an HTML element needs to be styled uniquely (no matter what classes are applied to the element), we can add an ID to the element. To add an ID to an element, the element needs an id attribute:

<h1 id="large-title"> ... </h1>
Then, CSS can select HTML elements by their id attribute. To select an id element, CSS prepends the id name with a hashtag (#). For instance, if we wanted to select the HTML element in the example above, it would look like this:

#large-title {

}
The id name is large-title, therefore the CSS selector for it is #large-title. -->

+++++++++++++++++++++++++

CSS SETUP AND SELECTORS
Classes and IDs

<!-- CSS can select HTML elements by their tag, class, and ID. CSS classes and IDs have different purposes, which can affect which one you use to style HTML elements.

CSS classes are meant to be reused over many elements. By writing CSS classes, you can style elements in a variety of ways by mixing classes on HTML elements.

For instance, imagine a page with two headlines. One headline needs to be bold and blue, and the other needs to be bold and green. Instead of writing separate CSS rules for each headline that repeat each other's code, it's better to write a .bold CSS rule, a .green CSS rule, and a .blue CSS rule. Then you can give one headline the bold green classes, and the other the bold blue classes.

While classes are meant to be used many times, an ID is meant to style only one element. As we'll learn in the next exercise, IDs override the styles of tags and classes. Since IDs override class and tag styles, they should be used sparingly and only on elements that need to always appear the same. -->

+++++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Specificity

<!-- Specificity is the order by which the browser decides which CSS styles will be displayed. A best practice in CSS is to style elements while using the lowest degree of specificity, so that if an element needs a new style, it is easy to override.

IDs are the most specific selector in CSS, followed by classes, and finally, tags. For example, consider the following HTML and CSS:

<h1 class="headline">Breaking News</h1>
h1 {
  color: red;
}

.headline {
  color: firebrick;
}
In the example code above, the color of the heading would be set to firebrick, as the class selector is more specific than the tag selector. If an ID attribute (and selector) were added to the code above, the styles within the ID selector's body would override all other styles for the heading. The only way to override an ID is to add another ID with additional styling.

Over time, as files grow with code, many elements may have IDs, which can make CSS difficult to edit, since a new, more specific style must be created to change the style of an element.

To make styles easy to edit, it's best to style with a tag selector, if possible. If not, add a class selector. If that is not specific enough, then consider using an ID selector. -->

++++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Chaining Selectors

<!-- When writing CSS rules, it's possible to require an HTML element to have two or more CSS selectors at the same time.

This is done by combining multiple selectors, which we will refer to as chaining. For instance, if there was a .special class for h1 elements, the CSS would look like:

h1.special {

}
The code above would select only the h1 elements that have a class of special. If a p element also had a class of special, the rule in the example would not style the paragraph. -->

+++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Nested Elements

<!-- In addition to chaining selectors to select elements, CSS also supports selecting elements that are nested within other HTML elements. For instance, consider the following HTML:

<ul class='main-list'>
  <li> ... </li>
  <li> ... </li>
  <li> ... </li>
</ul>
The nested <li> elements are selected with the following CSS:

.main-list li {

}
In the example above, .main-list selects the .main-list element (the unordered list element). The nested <li> are selected by adding li to the selector, separated by a space, resulting in .main-list li as the final selector (note the space in the selector).

Selecting elements in this way can make our selectors even more specific by making sure they appear in the context we expect. -->

++++++++++++++++++++++++++++++

CSS SETUP AND SELECTORS
Chaining and Specificity

<!-- In the last exercise, instead of selecting all h5 elements, you selected only the h5 elements nested inside the .description elements. This CSS selector was more specific than writing only h5. Adding more than one tag, class, or ID to a CSS selector increases the specificity of the CSS selector.

For instance, consider the following CSS:

p {
  color: blue;
}


.main p {
  color: red;
}
Both of these CSS rules define what a p element should look like. Since .main p has a class and a p tag as its selector, only the p elements inside the .main element will appear red. This occurs despite there being another more general rule that states p elements should be blue. -->

+++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Important

<!-- There is one thing that is even more specific than IDs: !important. !important can be applied to specific attributes instead of full rules. It will override any style no matter how specific it is. As a result, it should almost never be used. Once !important is used, it is very hard to override.

The syntax of !important in CSS looks like this:

p {
  color: blue !important;
}


.main p {
  color: red;
}
Since !important is used on the p selector’s color attribute, all p elements will appear blue, even though there is a more specific .main p selector that sets the color attribute to red.

The !important flag is only useful when an element appears the same way 100% of the time. Since it's almost impossible to guarantee that this will be true throughout a project and over time, it's best to avoid !important altogether. If you ever see !important used (or are ever tempted to use it yourself) we strongly recommend reorganizing your CSS. Making your CSS more flexible will typically fix the immediate problem and make your code more maintainable in the long run.
 -->

 +++++++++++++++++++++++++
 CSS SETUP AND SELECTORS
Multiple Selectors

<!-- In order to make CSS more concise, it's possible to add CSS styles to multiple CSS selectors all at once. This prevents writing repetitive code.

For instance, the following code has repetitive style attributes:

h1 {
  font-family: Georgia;
}

.menu {
  font-family: Georgia;
}
Instead of writing font-family: Georgia twice for two selectors, we can separate the selectors by a comma to apply the same style to both, like this:

h1, 
.menu {
  font-family: Georgia;
}
By separating the CSS selectors with a comma, both the h1 and the .menu elements will receive the font-family: Georgia styling. -->

+++++++++++++++++++++++++++++++++
CSS SETUP AND SELECTORS
Review CSS Selectors

style.css

p {
  font-family: Arial;
}

h1 {
  color: maroon;
}

h2.destination {
  font-family: cursive;
}

h5, p {
  font-family: Georgia;
}
h5 {
  color: rebeccapurple !important;
}
.description h5 {
  color: teal;
}

.title {
  color: teal;
}

.uppercase {
  text-transform: uppercase;
}
.publish-time {
  color: gray;
}

.cursive {
  font-family: cursive;
}

.capitalize {
  text-transform: capitalize;
}

==========================================
index.html 


<!DOCTYPE html>
<html>

<head>
  <title>Vacation World</title>
  <link href="style.css" type="text/css" rel="stylesheet">
</head>

<body>
  <img src="https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-2/explorer.jpeg" />
  <h1 class="title cursive capitalize" >Top Vacation Spots</h1>
  <h5>By: Stacy Gray</h5>
  <h6 class="publish-time">Published: 2 Days Ago</h6>

  <p>The world is full of fascinating places. Planning the perfect vacation involves packing up, leaving home, and experiencing something new.</p>

  <h2 class="destination">1. Florence, Italy</h2>
  <div class="description">A city-size shrine to the Renaissance, Florence offers frescoes, sculptures, churches, palaces, and other monuments from the richest cultural flowering the world has known. Names from its dazzling historical pastDante, Michelangelo, Galileo, Machiavelliare some of the most resonant of the medieval age. <a href="http://travel.nationalgeographic.com/travel/city-guides/florence-italy/" target="_blank">Learn More</a>.
    <h5>Top Attractions</h5>
    <ul>
      <li>Museums</li>
      <li>Bike Tours</li>
      <li>Historical Monuments</li>
    </ul>
  </div>

  <h2 class="destination">2. Beijing, China</h2>
  <div class="description">A city in the midst of reinventing itself and continuing to build on the success of the 2008 Summer Olympics, Beijing is a place of frenzied construction. New housing, new roads, and new sports venues seem to spring up overnight. At the same time, the capital of the Peoples Republic of China remains an epicenter of tradition, with the treasures of nearly 2,000 years as the imperial capital still on viewin the famed Forbidden City and in the luxuriant pavilions and gardens of the Summer Palace.
    <a href="http://travel.nationalgeographic.com/travel/city-guides/beijing-china/" target="_blank">Learn More</a>.
    <h5>Top Attractions</h5>
    <ul>
      <li>Biking</li>
      <li>Historical Sites</li>
      <li>Restaurants and Dining</li>
    </ul>
  </div>

  <h2 class="destination">3. Seoul, South Korea</h2>
  <div class="description">The Korean capital is a city of contrasts. Fourteenth-century city gates squat in the shadow of 21st-century skyscrapers, while the broad Han River is back-dropped by granite mountains rising in the city centercomplete with alpine highways speeding around their contours and temples nestling among their crags. Fashionable, gadget-laden youths battle for sidewalk space with fortune-tellers and peddlers, while tiny neighborhoods of traditional cottages contrast with endless ranks of identical apartments.
    <a href="http://travel.nationalgeographic.com/travel/city-guides/seoul-south-korea/" target="_blank">Learn More</a>.
    <h5>Top Attractions</h5>
    <ul>
      <li>Parasailing</li>
      <li>Segway Tours</li>
      <li>Spas and Resorts</li>
    </ul>
  </div>

  <h2> More Desinations </h2>
  <ul>
    <li><h4 class="destination">Jackson Hole, Wyoming</h4></li>
    <li><h4 class="destination">Cape Town, South Africa</h4></li>
    <li><h4 class="destination">La Paz, Bolivia</h4></li>
  </ul>

  <p>&mdash;Best of luck with your travels, and be sure to send pictures and stories. We"d love to hear them!</p>


</body>

</html>

-------------------------------------------------------------
02/01/2019

CSS VISUAL RULES
Introduction To Visual Rules

<!-- In this lesson, you'll learn the basic structure and syntax of CSS so that you can start styling web page elements.
 -->
++++++++++++++++++++++++++++++

CSS VISUAL RULES
CSS Structure

<!-- To style an HTML element using CSS, you need to write a CSS declaration inside the body of a CSS selector.

h1 {
  color: blue;
}
The example above selects the <h1> element. Inside of the selector's body, we typed color: blue. This line is referred to as a CSS declaration. CSS declarations consist of a property and a value.

Property — the property you'd like to style of that element (i.e., size, color, etc.).

Value — the value of the property (i.e., 18px for size, blue for color, etc.).

In the example above, the property is color and the value is blue. The property and value are separated by a colon (:). A semicolon (;) should always be used at the end of a declaration.

Finally, the entire snippet of code in the example above is known as a CSS rule or rule set. A CSS rule consists of the selector (here, h1) and all declarations inside of the selector. -->

++++++++++++++++++++++++++++++
CSS VISUAL RULES
Font Family

<!-- If you've ever used a formatted word processor, chances are that you probably also used a feature that allowed you change the font you were typing in. Font refers to the technical term typeface, or font family.

To change the typeface of text on your web page, you can use the font-family property.

h1 {
  font-family: Garamond;
}
In the example above, the font family for all main heading elements has been set to Garamond.

When setting typefaces on a web page, keep the following points in mind:

The font specified in a stylesheet must be installed on a user's computer in order for that font to display when a user visits the web page.
The default typeface for all HTML elements is Times New Roman. You may be familiar with this typeface if you have ever used a formatted word processor. If no font-family attribute is defined, the page will appear in Times New Roman.
It's a good practice to limit the number of typefaces used on a web page to 2 or 3. This helps the page load faster in some cases and is usually a good design decision.
When the name of a typeface consists of more than one word, it's a best practice to enclose the typeface's name in quotes, like so:
h1 {
  font-family: "Courier New";
}
You can find a reference of web safe fonts here. -->

++++++++++++++++++++++++++++
CSS VISUAL RULES
Font Size

<!-- Changing the typeface isn't the only way to customize text. Often times, different sections of a web page are highlighted by modifying the font size.

To change the size of text on your web page, you can use the font-size property.

p {
  font-size: 18px;
}
In the example above, the font-size of all paragraphs was set to 18px. px means pixels and is a way to measure font size. -->

++++++++++++++++++++++++++++++
CSS VISUAL RULES
Font Weight

<!-- In CSS, the font-weight property controls how bold or thin text appears.

p {
  font-weight: bold;
}
In the example above, all paragraphs on the web page would appear bolded.

The font-weight property has a another value: normal. Why does it exist?

If we wanted all text on a web page to appear bolded, we could select all text elements and change their font weight to bold. If a certain section of text was required to appear normal, however, we could set the font weight of that particular element to normal, essentially shutting off bold for that element. -->

+++++++++++++++++++++++++++++++
CSS VISUAL RULES
Text Align

<!-- No matter how much styling is applied to text (typeface, size, weight, etc.), text always appears on the left side of the browser.

To align text we can use the text-align property. The text-align property will align text to the element that holds it, otherwise known as its parent.

h1 {
  text-align: right;
}
The text-align property can be set to one of the following three values:

left — aligns text to the left hand side of its parent element, which in this case is the browser.
center — centers text inside of its parent element.
right — aligns text to the right hand side of its parent element. -->

++++++++++++++++++++++++++++++++
CSS VISUAL RULES
Color

<!-- Before discussing the specifics of color, it's important to make two distinctions about color. Color can affect the following design aspects:

Foreground color
Background color
Foreground color is the color that an element appears in. For example, when a heading is styled to appear green, the foreground color of the heading has been styled.

Conversely, when a heading is styled so that its background appears yellow, the background color of the heading has been styled.

In CSS, these two design aspects can be styled with the following two properties:

color: this property styles an element's foreground color
background-color: this property styles an element's background color
h1 {
  color: red;
  background-color: blue;
}
In the example above, the text of the heading will appear in red, and the background of the heading will appear blue. -->

++++++++++++++++++++++++++++++++
CSS VISUAL RULES
Opacity

<!-- Opacity is the measure of how transparent an element is. It's measured from 0 to 1, with 1 representing 100%, or fully visible and opaque, and 0 representing 0%, or fully invisible.

Opacity can be used to make elements fade into others for a nice overlay effect. To adjust the opacity of an element, the syntax looks like this:

.overlay {
  opacity: 0.5;
}
In the example above, the .overlay element would be 50% visible, letting whatever is positioned behind it show through. -->

+++++++++++++++++++++++++++++++
CSS VISUAL RULES
Background Image

<!-- CSS has the ability to change the background of an element. One option is to make the background of an element an image. This is done through the CSS property background-image. Its syntax looks like this:

.main-banner {
  background-image: url("https://www.example.com/image.jpg");
}
The background-image property will set the element's background to display an image.
The value provided to background-image is a url. The url should be a url to an image. The url can be a file within your project, or it can be a link to an external site. To link to an image inside an existing project, you must provide a relative file path. If there was an image folder in the project, with an image named mountains.jpg, the relative file path would look like:
.main-banner {
  background-image: url("images/mountains.jpg");
} -->

+++++++++++++++++++++++++++++++++++++++++++++++++
CSS VISUAL RULES
Review Visual Rules

body {
  /* Old browsers */
  background: #141E30;
  /* Chrome 10-25, Safari 5.1-6 */
  background: -webkit-linear-gradient(-45deg, #35577D, #141E30);
  /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
  background: linear-gradient(-45deg, #35577D, #141E30);
  margin: 0;
  padding: 0;
}

h1 {
  color: #FFF;
  font-size: 2em;
  padding-top: 100px;
  width: 100%;
  font-family: Georgia;
  text-align: center;
}

h2 {
  border-bottom: 1px solid rgba(255, 255, 255, 0.5);
  color: rgba(255, 255, 255, 0.5);
  font-weight: 100;
  font-size: 22px;
  line-height: 24px;
  padding-bottom: 30px;
  text-align: left;
  width: 70%;
  font-family: Georgia
}

p {
  color: AliceBlue;
  line-height: 1.3em;
  text-align: left;
  width: 100%;
  font-family: Helvetica;
  font-size: 18px;
  font-weight: bold;
    
}

.byline {
  font-family: Helvetica;
  color: rgba(255, 255, 255, 0.5);
  float: left;
  font-size: 14px;
  padding-left: 10px;
  text-transform: uppercase;
}

.caption {
  display: block;
  font-family: 'Playfair Display', serif;
  font-size: 14px;
  font-style: italic;
  line-height: 14px;
  margin-left: 20px;
  padding: 10px;
  position: relative;
  top: 80%;
  width: 60%;
  background-color: white;
  color: black;
  opacity: 0.75;
}

.content {
  padding: 40px;
}

.image {
  background-image: url("https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-2/soccer.jpeg");
  background-size: cover;
  background-position: center;
  height: 300px;
}

.writer-img {
  -webkit-box-shadow: 5px 0px 5px 0px rgba(0, 0, 50, 0.97);
  -moz-box-shadow: 5px 0px 5px 0px rgba(0, 0, 50, 0.97);
  box-shadow: 5px 0px 5px 0px rgba(0, 0, 50, 0.97);
  float: left;
  width: 50px;
}


++++++++++++++++++++++++++++++
body {
  /* Old browsers */
  background: #141E30;
  /* Chrome 10-25, Safari 5.1-6 */
  background: -webkit-linear-gradient(-45deg, #35577D, #141E30);
  /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
  background: linear-gradient(-45deg, #35577D, #141E30);
  margin: 0;
  padding: 0;
}

h1 {
  color: #FFF;
  font-size: 2em;
  padding-top: 100px;
  width: 100%;
  font-family: Georgia;
  text-align: center;
}

h2 {
  border-bottom: 1px solid rgba(255, 255, 255, 0.5);
  color: rgba(255, 255, 255, 0.5);
  font-weight: 100;
  font-size: 22px;
  line-height: 24px;
  padding-bottom: 30px;
  text-align: left;
  width: 70%;
  font-family: Georgia
}

p {
  color: AliceBlue;
  line-height: 1.3em;
  text-align: left;
  width: 100%;
  font-family: Helvetica;
  font-size: 18px;
  font-weight: bold;
    
}

.byline {
  font-family: Helvetica;
  color: rgba(255, 255, 255, 0.5);
  float: left;
  font-size: 14px;
  padding-left: 10px;
  text-transform: uppercase;
}

.caption {
  display: block;
  font-family: 'Playfair Display', serif;
  font-size: 14px;
  font-style: italic;
  line-height: 14px;
  margin-left: 20px;
  padding: 10px;
  position: relative;
  top: 80%;
  width: 60%;
  background-color: white;
  color: black;
  opacity: 0.75;
}

.content {
  padding: 40px;
}

.image {
  background-image: url("https://s3.amazonaws.com/codecademy-content/courses/freelance-1/unit-2/soccer.jpeg");
  background-size: cover;
  background-position: center;
  height: 300px;
}

.writer-img {
  -webkit-box-shadow: 5px 0px 5px 0px rgba(0, 0, 50, 0.97);
  -moz-box-shadow: 5px 0px 5px 0px rgba(0, 0, 50, 0.97);
  box-shadow: 5px 0px 5px 0px rgba(0, 0, 50, 0.97);
  float: left;
  width: 50px;
}

----------------------------------------------------------------
03/01/2019

THE BOX MODEL
Introduction to the Box Model

<!-- Browsers load HTML elements with default position values. This often leads to an unexpected and unwanted user experience, while limiting the views you can create. In this lesson you will learn about the box model, an important concept to understand how elements are positioned and displayed on a website.

If you have used HTML and CSS, you have unknowingly seen aspects of the box model. For example, if you have set the background color of an element, you may have noticed that the color was applied not only to the area directly behind the element, but also to the area to the right of the element. Also, if you have aligned text, you know it is aligned relative to something. What is that something?

All elements on a web page are interpreted by the browser as "living" inside of a box. This is what is meant by the box model.

For example, when you change the background color of an element, you change the background color of its entire box.

In this lesson, you'll learn about the following aspects of the box model:

The dimensions of an element's box.
The borders of an element's box.
The paddings of an element's box.
The margins of an element's box.
Let's begin!
 -->
 +++++++++++++++++++++++++++++++++++
 THE BOX MODEL
The Box Model

<!-- The box model comprises the set of properties which define parts of an element that take up space on a web page. The model includes the content area's size (width and height) and the element's padding, border, and margin. The properties include:

Width and height — specifies the width and height of the content area.
Padding — specifies the amount of space between the content area and the border.
Border — specifies the thickness and style of the border surrounding the content area and padding.
Margin — specifies the amount of space between the border and the outside edge of the element.
The image to the right is a visual representation of the box model.

Open the box model image in a new tab so you can reference the box model as you move through the lesson. -->

++++++++++++++++++++++++++++++++++++
THE BOX MODEL
Height and Width

<!-- An element's content has two dimensions: a height and a width. By default, the dimensions of an HTML box are set to hold the raw contents of the box.

The CSS height and width properties can be used to modify these default dimensions.

p {
  height: 80px;
  width: 240px;
}
In this example, the height and width of paragraph elements are set to 80 pixels and 240 pixels, respectively — the px in the code above stands for pixels.

Pixels allow you to set the exact size of an element's box (width and height). When the width and height of an element are set in pixels, it will be the same size on all devices — an element that fills a laptop screen will overflow a mobile screen. -->

++++++++++++++++++++++++++++++++++
THE BOX MODEL
Borders

<!-- A border is a line that surrounds an element, like a frame around a painting. Borders can be set with a specific width, style, and color.

width — The thickness of the border. A border's thickness can be set in pixels or with one of the following keywords: thin, medium, or thick.
style — The design of the border. Web browsers can render any of 10 different styles. Some of these styles include: none, dotted, and solid.
color — The color of the border. Web browsers can render colors using a few different formats, including 140 built-in color keywords.
p {
  border: 3px solid coral;
}
In the example above, the border has a width of 3 pixels, a style of solid and a color of coral. All three properties are set in one line of code.

The default border is medium none color, where color is the current color of the element. If width, style, or color are not set in the CSS file, the web browser assigns the default value for that property.

p.content-header {
  height: 80px;
  width: 240px;
  border: solid coral;
}
In this example, the border style is set to solid and the color is set to coral. The width is not set, so it defaults to medium. -->

++++++++++++++++++++++++++++++++
THE BOX MODEL
Border Radius

<!-- Ever since we revealed the borders of boxes, you may have noticed that the borders highlight the true shape of an element's box: square. Thanks to CSS, a border doesn't have to be square.

You can modify the corners of an element's border box with the border-radius property.

div.container {
  border: 3px solid rgb(22, 77, 100);
  border-radius: 5px;
}
The code in the example above will set all four corners of the border to a radius of 5 pixels (i.e. the same curvature that a circle with radius 5 pixels would have).

You can create a border that is a perfect circle by setting the radius equal to the height of the box, or to 100%.

div.container {
  height: 60px;
  width: 60px;
  border: 3px solid rgb(22, 77, 100);
  border-radius: 100%;
}
The code in the example above creates a <div> that is a perfect circle. -->

+++++++++++++++++++++++++++++
THE BOX MODEL
Padding I

<!-- The space between the contents of a box and the borders of a box is known as padding. Padding is like the space between a picture and the frame surrounding it. In CSS, you can modify this space with the padding property.

p.content-header {
  border: 3px solid coral;
  padding: 10px;
}
The code in this example puts 10 pixels of space between the content of the paragraph (the text) and the borders, on all four sides.

The padding property is often used to expand the background color and make content look less cramped.

If you want to be more specific about the amount of padding on each side of a box's content, you can use the following properties:

padding-top
padding-right
padding-bottom
padding-left
Each property affects the padding on only one side of the box's content, giving you more flexibility in customization.

p.content-header {
  border: 3px solid fuschia;
  padding-bottom: 10px;
}
In the example above, only the bottom side of the paragraph's content will have a padding of 10 pixels.	 -->

++++++++++++++++++++++++++++++++++++=

THE BOX MODEL
Padding II

<!-- Another implementation of the padding property lets you specify exactly how much padding there should be on each side of the content in a single declaration.

p.content-header {
  border: 3px solid grey;
  padding: 6px 11px 4px 9px;
}
In the example above, the four values 6px 11px 4px 9px correspond to the amount of padding in a clockwise rotation. In order, it specifies the amount of padding on the top (6 pixels), right (11 pixels), bottom (4 pixels), and left (9 pixels) sides of the content.

When using this implementation of the padding property, we must specify a padding value for all four sides of the element.

However, if the top and bottom values for padding will equal each other, and the left and right values for padding will also equal each other, you can use the following shortcut:

p.content-header {
  padding: 5px 10px;
}
The first value, 5px, sets the padding value for the top and bottom sides of the content. The second value, 10px, sets the padding value for the left and right sides of the content. -->

+++++++++++++++++++++++++++++++++++++++
THE BOX MODEL
Margins I

<!-- So far you've learned about the following components of the box model: content, borders, and padding. The fourth and final component of the box model is margin.

Margin refers to the space directly outside of the box. The margin property is used to specify the size of this space.

p {
  border: 1px solid aquamarine;
  margin: 20px;
}
The code in the example above will place 20 pixels of space on the outside of the paragraph's box on all four sides. This means that other HTML elements on the page cannot come within 20 pixels of the paragraph's border.

If you want to be even more specific about the amount of margin on each side of a box, you can use the following properties:

margin-top
margin-right
margin-bottom
margin-left
Each property affects the margin on only one side of the box, providing more flexibility in customization.

p {
  border: 3px solid DarkSlateGrey;
  margin-right: 15px;
}
In the example above, only the right side of the paragraph's box will have a margin of 15 pixels. It's common to see margin values used for a specific side of an element. -->

++++++++++++++++++++++++++++++++++++++++++++
THE BOX MODEL
Margins II

<!-- What if you don't want equal margins on all four sides of the box?

A similar implementation of the margin property is used to specify exactly how much margin there should be on each side of the box in a single declaration.

p {
  margin: 6px 10px 5px 12px;
}
In the example above, the four values 6px 10px 5px 12px refer to the amount of margin around the box in a clockwise rotation. In order, it specifies the amount of margin on the top (6 pixels), right (10 pixels), bottom (5 pixels), and left (12 pixels) sides of the box.

When using this implementation of the margin property, the margin value must be specified for all four sides of the box.

Just like the padding shortcut, when you're certain that the top and bottom values for margin will equal each other, and that the left and right values for margin will also equal each other, you can use the following shortcut:

p {
  margin: 6px 12px;
}
The first value, 6px, sets a margin value for the top and bottom of the box. The second value, 12px, sets a margin value for the left and right sides of the box. -->

+++++++++++++++++++++++++++++++++++++
THE BOX MODEL
Auto

<!-- The margin property also lets you center content. However, you must follow a few syntax requirements. Take a look at the following example:

div {
  margin: 0 auto;
}
In the example above, margin: 0 auto; will center the divs in their containing elements. The 0 sets the top and bottom margins to 0 pixels. The auto value instructs the browser to adjust the left and right margins until the element is centered within its containing element.

The div elements in the example above should center within an element that fills the page, but this doesn't occur. Why?

In order to center an element, a width must be set for that element. Otherwise, the width of the div will be automatically set to the full width of its containing element, like the <body>, for example. It's not possible to center an element that takes up the full width of the page.

div.headline {
  width: 400px;
  margin: 0 auto;
}
In the example above, the width of the div is set to 400 pixels, which is less than the width of most screens. This will cause the div to center within a containing element that is greater than 400 pixels wide.
 -->

 +++++++++++++++++++++++++++++++++++++++++
 THE BOX MODEL
Margin Collapse

<!-- As you have seen, padding is space added inside an element's border, while margin is space added outside an element's border. One additional difference is that top and bottom margins, also called vertical margins, collapse, while top and bottom padding does not.

Horizontal margins (left and right), like padding, are always displayed and added together. For example, if two divs with ids #div-one and #div-two, are next to each other, they will be as far apart as the sum of their adjacent margins.

#img-one {
  margin-right: 20px;
}

#img-two {
  margin-left: 20px;
}
In this example, the space between the #img-one and #img-two borders is 40 pixels. The right margin of #img-one (20px) and the left margin of #img-two (20px) add to make a total margin of 40 pixels.

Unlike horizontal margins, vertical margins do not add. Instead, the larger of the two vertical margins sets the distance between adjacent elements.

#img-one {
  margin-bottom: 30px;
}

#img-two {
  margin-top: 20px;
}
In this example, the vertical margin between the #img-one and #img-two elements is 30 pixels. Although the sum of the margins is 50 pixels, the margin collapses so the spacing is only dependent on the #img-one bottom margin.

It may be helpful to think of collapsing vertical margins as a short person trying to push a taller person. The tall person has longer arms and can easily push the short person, while the person with short arms cannot reach the person with long arms. -->

+++++++++++++++++++++++++++++++++
THE BOX MODEL
Minimum and Maximum Height and Width

<!-- Because a web page can be viewed through displays of differing screen size, the content on the web page can suffer from those changes in size. To avoid this problem, CSS offers two properties that can limit how narrow or how wide an element's box can be sized to.

min-width — this property ensures a minimum width of an element's box.
max-width — this property ensures a maximum width of an element's box.
p {
  min-width: 300px;
  max-width: 600px;
}
In the example above, the width of all paragraphs will not shrink below 300 pixels, nor will the width exceed 600 pixels.

Content, like text, can become difficult to read when a browser window is narrowed or expanded. These two properties ensure that content is legible by limiting the minimum and maximum widths of an element.

You can also limit the minimum and maximum height of an element.

min-height — this property ensures a minimum height for an element's box.
max-height — this property ensures a maximum height of an element's box.
p {
  min-height: 150px;
  max-height: 300px;
}
In the example above, the height of all paragraphs will not shrink below 150 pixels and the height will not exceed 300 pixels.

What will happen to the contents of an element's box if the max-height property is set too low? It's possible for the content to spill outside of the box, resulting in content that is not legible. You'll learn how to work around this issue in the next exercise.
 -->

 ++++++++++++++++++++++++++++++++

 THE BOX MODEL
Overflow


<!-- All of the components of the box model comprise an element’s size. For example, an image that has the following dimensions is 364 pixels wide and 244 pixels tall.

300 pixels wide
200 pixels tall
10 pixels padding on the left and right
10 pixels padding on the top and bottom
2 pixels border on the left and right
2 pixels border on the top and bottom
20 pixels margin on the left and right
10 pixels margin on the top and bottom
The total dimensions (364px by 244px) are calculated by adding all of the vertical dimensions together and all of the horizontal dimensions together. Sometimes, these components result in an element that is larger than the parent's containing area.

How can we ensure that we can view all of an element that is larger than its parent's containing area?

The overflow property controls what happens to content that spills, or overflows, outside its box. It can be set to one of the following values:

hidden - when set to this value, any content that overflows will be hidden from view.
scroll - when set to this value, a scrollbar will be added to the element's box so that the rest of the content can be viewed by scrolling.
visible - when set to this value, the overflow content will be displayed outside of the containing element. Note, this is the default value.
p {
  overflow: scroll; 
}
In the example above, if any of the paragraph content overflows (perhaps a user resizes their browser window), a scrollbar will appear so that users can view the rest of the content.

The overflow property is set on a parent element to instruct a web browser how to render child elements. For example, if a div’s overflow property is set to scroll, all children of this div will display overflowing content with a scroll bar. -->

++++++++++++++++++++++++++++++++

THE BOX MODEL
Resetting Defaults

<!-- All major web browsers have a default stylesheet they use in the absence of an external stylesheet. These default stylesheets are known as user agent stylesheets. In this case, the term "user agent" is a technical term for the browser.

User agent stylesheets often have default CSS rules that set default values for padding and margin. This affects how the browser displays HTML elements, which can make it difficult for a developer to design or style a web page.

Many developers choose to reset these default values so that they can truly work with a clean slate.

* {
  margin: 0;
  padding: 0;
}
The code in the example above resets the default margin and padding values of all HTML elements. It is often the first CSS rule in an external stylesheet.

Note that both properties are both set to 0. When these properties are set to 0, they do not require a unit of measurement.
	 -->

++++++++++++++++++++++++++=

THE BOX MODEL
Visibility

<!-- Elements can be hidden from view with the visibility property.

The visibility property can be set to one of the following values:

hidden — hides an element.
visible — displays an element.
<ul>
  <li>Explore</li>
  <li>Connect</li>
  <li class="future">Donate</li>
<ul>
.future {
  visibility: hidden;
}
In the example above, the list item with a class of future will be hidden from view in the browser.

Keep in mind, however, that users can still view the contents of the list item (e.g., Donate) by viewing the source code in their browser. Furthermore, the web page will only hide the contents of the element. It will still leave an empty space where the element is intended to display.

Note: What's the difference between display: none and visibility: hidden? An element with display: none will be completely removed from the web page. An element with visibility: hidden, however, will not be visible on the web page, but the space reserved for it will.	  -->

#style.css 

body {
  background-color: white;
  font-family: 'Raleway', sans-serif;
}

.navigation ul {
  margin: 0;
  padding: 0;
  text-align: center;
}

.navigation li {
  font-weight: 100;
  letter-spacing: 2px;
  padding: 20px;
}

.navigation  li.logo {
  color: black;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: 4px;
}

#banner {
  background-image: url("https://s3.amazonaws.com/codecademy-content/courses/web-101/unit-6/htmlcss1-img_tahoe.jpeg");
  background-size: cover;
  background-position: bottom center;
  height: 700px;
  width: 100%;
}

#banner .content h1 {
  border: 3px solid white;
  position: relative;
  top: 50px;
  width: 400px;
  margin: 0 auto;
}

#main {
  margin: 0 auto;
  padding: 40px;
  text-align: center;
  width: 400px;
  height: 1000px;
  overflow: scroll;
}

h1 {
  color: white;
  font-size: 42px;
  font-weight: 600;
  text-align: center;
}

h2 {
  border: 1px dotted red;
  color: red;
  font-size: 14px;
  line-height: 48px;
  padding: 20px 30px;
  margin: 30px 20px;
  text-align: center;
}

h3 {
  color: red;
  font-size: 26px;
  font-weight: 700;
  padding: 20px 10px;
}

p {
  color: grey;
  font-size: 16px;
  line-height: 48px;
  margin-top: 60px;
  padding: 10px 20px;
}

.pull-quote {
  margin: 0 auto;
  width: 400px;
}

.byline {
  border-bottom: 1px solid LightGrey;
  border-top: 1px solid LightGrey;
  color: DarkGrey;
  font-size: 14px;
  font-weight: 200;
}

.share {
  border: 1px solid LightGrey;
  padding: 40px 0px;
  position: relative;
  text-align: center;
  width: 100%;
}

.share a {
  background: red;
  border: 1px solid red;
  border-radius: 3px;
  color: white;
  display: inline-block;
  margin: 10px;
  padding: 14px;
  text-decoration: none;
}

.share a:hover {
  background: white;
  border: 1px solid red;
  color: red;
}

------------------------------------------------------------------------
CHANGING THE BOX MODEL
Why Change the Box Model?

<!-- The last lesson focused on the most important aspects of the box model: box dimensions, borders, padding, and margin.

The box model, however, has an awkward limitation regarding box dimensions. This limitation is best illustrated with an example.

<h1>Hello World</h1>
h1 {
  border: 1px solid black;
  height: 200px;
  width: 300px;
  padding: 10px;
}
In the example above, a heading element's box has solid, black, 1 pixel thick borders. The height of the box is 200 pixels, while the width of the box is 300 pixels. A padding of 10 pixels has also been set on all four sides of the box's content.

Unfortunately, under the current box model, the border thickness and the padding will affect the dimensions of the box.

The 10 pixels of padding increases the height of the box to 220 pixels and the width to 320 pixels. Next, the 1-pixel thick border increases the height to 222 pixels and the width to 322 pixels.

Under this box model, the border thickness and padding are added to the overall dimensions of the box. This makes it difficult to accurately size a box. Over time, this can also make all of a web page's content difficult to position and manage.

In this brief lesson, you'll learn how to use a different technique that avoids this problem altogether. -->

++++++++++++++++++++++++++++
CHANGING THE BOX MODEL
Box Model: Content-Box

<!-- Many properties in CSS have a default value and don't have to be explicitly set in the stylesheet.

For example, the default font-weight of text is normal, but this property-value pair is not typically specified in a stylesheet.

The same can be said about the box model that browsers assume. In CSS, the box-sizing property controls the type of box model the browser should use when interpreting a web page.

The default value of this property is content-box. This is the same box model that is affected by border thickness and padding. -->

++++++++++++++++++++++++++++++++
CHANGING THE BOX MODEL
Box Model: Border-Box

<!-- Fortunately, we can reset the entire box model and specify a new one: border-box.

* {
  box-sizing: border-box;
}
The code in the example above resets the box model to border-box for all HTML elements. This new box model avoids the dimensional issues that exist in the former box model you learned about.

In this box model, the height and width of the box will remain fixed. The border thickness and padding will be included inside of the box, which means the overall dimensions of the box do not change.

<h1>Hello World</h1>
* {
  box-sizing: border-box;
}

h1 {
  border: 1px solid black;
  height: 200px;
  width: 300px;
  padding: 10px;
}
In the example above, the height of the box would remain at 200 pixels and the width would remain at 300 pixels. The border thickness and padding would remain entirely inside of the box. -->
+++++++++++++++++++++++++++
CHANGING THE BOX MODEL
The New Box Model

<!-- Now that you know about the new box model, let's actually implement it in the browser.

* {
  box-sizing: border-box;
}
It's that simple! In the example above, the universal selector (*) targets all elements on the web page and sets their box model to the border-box model.
 -->
 In style.css, change the box model for all elements on the web page to the new box model.

You probably didn't see a difference in the web page to the right - that's ok! The new box model simply makes sure that the dimensions of elements remains the same regardless of border width and padding.

-------------------------------------------------------------------
03/01/2019

CSS DISPLAY AND POSITIONING
Flow of HTML

<!-- A browser will render the elements of an HTML document that has no CSS from left to right, top to bottom, in the same order as they exist in the document. This is called the flow of elements in HTML.

In addition to the properties that it provides to style HTML elements, CSS includes properties that change how a browser positions elements. These properties specify where an element is located on a page, if the element can share lines with other elements, and other related attributes.

In this lesson, you will learn five properties for adjusting the position of HTML elements in the browser:

position
display
z-index
float
clear
Each of these properties will allow us to position and view elements on a web page. They can be used in conjunction with any other styling properties you may know.

 -->

 +++++++++++++++++++++++++++++=
CSS DISPLAY AND POSITIONING
Position

<!-- Take a look at the block-level elements in the image below:
Block-level elements like these boxes create a block the full width of their parent elements, and they prevent other elements from appearing in the same horizontal space. The boxes in the image above were created with the following CSS:

.boxes {
  width: 120px;
  height: 70px;
}
and the following HTML:

<div class="boxes"></div>
<div class="boxes"></div>
Notice the block-level elements in the image above take up their own line of space and therefore don't overlap each other. In the browser to the right you can see block-level elements also consistently appear on the left side of the browser. This is the default position for block-level elements.

The default position of an element can be changed by setting its position property. The position property can take one of four values:

static - the default value (it does not need to be specified)
relative
absolute
fixed
In the next few exercises, you'll learn about the values in items 2, 3, and 4 above. For now, it's important to understand that if you favor the default position of an HTML element, you don't need to set its position property. -->

++++++++++++++++++++++++++++++=
CSS DISPLAY AND POSITIONING
Position: Relative

<!-- 
One way to modify the default position of an element is by setting its position property to relative.

This value allows you to position an element relative to its default static position on the web page.

.box-bottom {
  background-color: DeepSkyBlue;
  position: relative;
}
Although the code in the example above instructs the browser to expect a relative positioning of the div, it does not specify where the div should be positioned on the page.

.box-bottom {
  background-color: DeepSkyBlue;
  position: relative;
  top: 20px;
  left: 50px;
}
In the example above, the <div> has been positioned using two of the four offset properties. The valid offset properties are:

top - moves the element down.
bottom - moves the element up.
left - moves the element right.
right - moves the element left.
In the example above, the <div> will be moved down 20 pixels and to the right 50 pixels from its default static position. The image below displays the new position of the box. The dotted line represents where the statically positioned (default) box was positioned.
Units for offset properties can be specified in pixels, ems, or percentages. Note that offset properties will not work if the value of the element's position property is the default static. -->

++++++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Position: Absolute

<!-- Another way of modifying the position of an element is by setting its position to absolute.

When an element's position is set to absolute all other elements on the page will ignore the element and act like it is not present on the page. The element will be positioned relative to its closest positioned parent element.

.box-bottom {
  background-color: DeepSkyBlue;
  position: absolute;
  top: 20px;
  left: 50px;
}
In the example above, the .box-bottom <div> will be moved down and right from the top left corner of the view. If offset properties weren't specified, the top box would be entirely covered by the bottom box. Take a look at the gif below:



The bottom box in this image (colored blue) is displaced from the top left corner of its container. It is 20 pixels lower and 50 pixels to the right of the top box.

In the next exercise, we will compare the scrolling of absolute elements with fixed elements. -->

+++++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Position: Fixed

<!-- When an element's position is set to absolute, as in the last exercise, the element will scroll with the rest of the document when a user scrolls.

We can fix an element to a specific position on the page (regardless of user scrolling) by setting its position to fixed.

.box-bottom {
  background-color: DeepSkyBlue;
  position: fixed;
  top: 20px;
  left: 50px;

}
In the example above, the .box-bottom <div> will remain fixed to its position no matter where the user scrolls on the page, like in the image below:
This technique is often used for navigation bars on a web page. -->

+++++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Z-Index

<!-- When boxes on a web page have a combination of different positions, the boxes (and therefore, their content) can overlap with each other, making the content difficult to read or consume.

.box-top {
  background-color: Aquamarine;
}

.box-bottom {
  background-color: DeepSkyBlue;
  position: absolute;
  top: 20px;
  left: 50px;
}
In the example above, the .box-bottom <div> ignores the .box-top <div> and overlaps it as a user scrolls.

The z-index property controls how far "back" or how far "forward" an element should appear on the web page when elements overlap. This can be thought of the depth of elements, with deeper elements appearing behind shallower elements.

The z-index property accepts integer values. Depending on their values, the integers instruct the browser on the order in which elements should be displayed on the web page.

.box-top {
  background-color: Aquamarine;
  position: relative;
  z-index: 2;
}

.box-bottom {
  background-color: DeepSkyBlue;
  position: absolute;
  top: 20px;
  left: 50px;
  z-index: 1;
}
In the example above, we set the .box-top position to relative and the z-index to 2. We changed position to relative, because the z-index property does not work on static elements. The z-index of 2 moves the .box-top element forward, because it is greater than the .box-bottom z-index, 1. See the example image below:
In the image above, you can see the top box is moved in front of the bottom box. -->

+++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Inline Display

<!-- Every HTML element has a default display value that dictates if it can share horizontal space with other elements. Some elements fill the entire browser from left to right regardless of the size of their content. Other elements only take up as much horizontal space as their content requires and can be directly next to other elements.

In this lesson, we’ll cover three values for the display property: inline, block, and inline-block.

The default display for some tags, such as <em>, <strong>, and <a>, is called inline. """"Inline elements have a box that wraps tightly around their content, only taking up the amount of space necessary to display their content and not requiring a new line after each element. The height and width of these elements cannot be specified in the CSS document""". For example, the text of an anchor tag (<a>) will, by default, be displayed on the same line as the surrounding text, and it will only be as wide as necessary to contain its content. inline elements cannot be altered in size with the height or width CSS properties.

To learn more about <em>inline</em> elements, read <a href="#">MDN documentation</a>.
In the example above, the <em> element is inline, because it displays its content on the same line as the content surrounding it, including the anchor tag. This example will display:

To learn more about inline elements, click MDN documentation.

The CSS display property provides the ability to make any element an inline element. This includes elements that are not inline by default such as paragraphs, divs, and headings.

h1 {
  display: inline;
}
The CSS in the example above will change the display of all <h1> elements to inline. The browser will render <h1> elements on the same line as other inline elements immediately before or after them (if there are any). -->

#1. In index.html, add opening and closing <strong></strong> tags around "Welcome." Notice that the element does not move. That's because <strong> elements are inline, so they can share lines with other elements.	In index.html, add opening and closing <strong></strong> tags around "Welcome." Notice that the element does not move. That's because <strong> elements are inline, so they can share lines with other elements.

++++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Block Display

<!-- Some elements are not displayed in the same line as the content around them. These are called block-level elements. """These elements fill the entire width of the page by default, but their width property can also be set. Unless otherwise specified, they are the height necessary to accommodate their content."""

Elements that are block-level by default include all levels of heading elements (<h1> through <h6>), <p>, <div> and <footer>. For a complete list of block level elements, visit the MDN documentation.

strong {
  display: block;
}
In the example above, all <strong> elements will be displayed on their own line, with no content directly on either side of them even though their contents may not fill the width of most computer screens. -->

++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Inline-Block Display

<!-- The third value for the display property is inline-block. Inline-block display combines features of both inline and block elements. Inline-block elements can appear next to each other and we can specify their dimensions using the width and height properties. Images are the best example of default inline-block elements.

For example, <div>s in the CSS below will be displayed on the same line and with the specified dimensions:

<div class="rectangle">
  <p>I’m a rectangle!</p>
</div>
<div class="rectangle">
  <p>So am I!</p>
</div>
<div class="rectangle">
  <p>Me three!</p>
</div>
.rectangle {
  display: inline-block;
  width: 200px;
  height: 300px;
}
In the example above, there are three rectangular divs that each contain a paragraph of text. The .rectangle <div>s will all appear inline (provided there is enough space from left to right) with a width of 200 pixels and height of 300 pixels, even though the text inside of them may not require 200 pixels by 300 pixels of space.
 -->

1.Let's fix the display of the <li> tags in the menu at the top of the page.

Set the display property of li elements to inline-block.

2.
Set the width of the li elements to 80 pixels.

3.
Now, we can reduce the top offset of the "Welcome" section. Set it to 50 pixels.

4.
Set the display property of .answer elements to inline-block.

++++++++++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Float

<!-- So far, you've learned how to specify the exact position of an element using offset properties. If you're simply interested in moving an element as far left or as far right as possible on the page, you can use the float property.

The float property can be set to one of two values:

left - this value will move, or float, elements as far left as possible.
right - this value will move elements as far right as possible.
.boxes {
  width: 120px;
  height: 70px;
}

.box-bottom {
  background-color: DeepSkyBlue;
  float: right;
}
In the example above, we float the .box-bottom element to the right. This works for static and relative positioned elements. See the result of the code below:



Floated elements must have a width specified, as in the example above. Otherwise, the element will assume the full width of its containing element, and changing the float value will not yield any visible results. -->

#1.Set the float property of the .answer element to left.

++++++++++++++++++++++++++++++++++
CSS DISPLAY AND POSITIONING
Clear

<!-- The float property can also be used to float multiple elements at once. However, when multiple floated elements have different heights, it can affect their layout on the page. Specifically, elements can "bump" into each other and not allow other elements to properly move to the left or right.

The clear property specifies how elements should behave when they bump into each other on the page. It can take on one of the following values:

left — the left side of the element will not touch any other element within the same containing element.
right — the right side of the element will not touch any other element within the same containing element.
both — neither side of the element will touch any other element within the same containing element.
none — the element can touch either side.
div {
  width: 200px;
  float: left;
}

div.special {
  clear: left;
}
In the example above, all <div>s on the page are floated to the left side. The element with class special did not move all the way to the left because a taller <div> blocked its positioning. By setting its clear property to left, the special <div> will be moved all the way to the left side of the page. -->

1.
Take a look at the .answer divs on the web page. They have been floated to the left, but the .question divs are touching the .answer divs on the right, let's fix this.

In the .question selector, set the clear property to left. Notice how the questions moved.

2.
On second thought, this layout is not looking so good. Remove the float property from .answer and the clear property from .question.	


---------------------------------------------------------

CSS COLOR
Introduction to Color

<!-- CSS supports a wide variety of colors. These include named colors, like blue, black, and LimeGreen, along with colors described by a numeric value. Using a numeric system allows us to take advantage of the whole spectrum of colors that browsers support. In this lesson, we're going to explore all the color options CSS offers.

Colors in CSS can be described in three different ways:

Named colors — English words that describe colors, also called keyword colors
RGB — numeric values that describe a mix of red, green, and blue
HSL — numeric values that describe a mix of hue, saturation, and lightness
We'll learn about and explore the benefits of each of these in depth. Using only named colors, you may feel like you're picking labeled crayons out of a box. By the end of this lesson, you'll feel like a painter mixing paints on a palette. -->

+++++++++++++++++++++++++++++
CSS COLOR
Foreground vs Background

<!-- Before discussing the specifics of color, it's important to make two distinctions about color. Color can affect the following design aspects:

The foreground color
The background color
Foreground color is the color that an element appears in. For example, when a heading is styled to appear green, the foreground color of the heading has been styled.

Conversely, when a heading is styled so that its background appears yellow, the background color of the heading has been styled

In CSS, these two design aspects can be styled with the following two properties:

color - this property styles an element's foreground color.
background-color - this property styles an element's background color.
h1 {
  color: Red;
  background-color: Blue;
}
In the example above, the text of the heading will appear in red, and the background of the heading will appear blue. -->

1.
In style.css, set the foreground color of the h1 heading to MidnightBlue.

2.
Next, set the background color of the h1 heading to Aqua.

Notice that the background-color property did not change the background color of the entire page. Instead, only the background area behind heading changed. We'll learn why this occurs in more detail later in the course.

Note: The background color of the heading will block the image of the coffee.

+++++++++++++++++++++++++
CSS COLOR
Hexadecimal

<!-- One syntax that we can use to specify colors is called hexadecimal. Colors specified using this system are called hex colors. A hex color begins with a hash character (#) which is followed by three or six characters. The characters represent values for red, blue and green.

DarkSeaGreen: #8FBC8F
Sienna:       #A0522D
SaddleBrown:  #8B4513
Brown:        #A52A2A
Black:        #000000 or #000
White:        #FFFFFF or #FFF
Aqua:         #00FFFF or #0FF
In the example above, you may notice that there are both letters and numbers in the values. This is because the hexadecimal number system has 16 digits (0-15) instead of 10 (0-9) like you are used to. To represent 10-15, we use A-F. Here is a list of many different colors and their hex values.

Notice that Black, White, and Aqua are all represented with both three characters and six characters. This can be done with hex colors whose number pairs are the same characters. In the example above, Aqua can be represented as #0FF because both of the first two characters are 0 and the second and third pairs of characters are both Fs. Keep in mind that all three character hex colors can be represented with six characters (by repeating each character twice) but the same is not true in reverse.

You can include hex colors just as you would include named colors: background-color: #9932cc;.
 -->
1.
In the browser is a web page that uses named colors and hex colors. We're going to translate the named colors into hex, to be more consistent. The colors won't visually change, yet.

In style.css, find the CSS rule that uses the named color DarkSeaGreen and change it to its hex value, #8FBC8F.

2.
Find the four other named colors of the roast types and convert them to their hex values, as shown here:

++++++++++++++++++++++++++++++++++++++++++

CSS COLOR
RGB Colors

<!-- There is another syntax for representing RGB values that uses decimal numbers. It looks like this:

h1 {
  color: rgb(23, 45, 23);
}
Here, each of the three values represents a color component, and each can have a decimal number value from 0 to 255. The first number represents the amount of red, the second is green, and the third is blue. These colors are exactly the same as hex, but with a different syntax and a different number system.

In general, hex and decimal color representations are equivalent. Which you choose is a matter of personal taste. That said, it's good to choose one and be consistent throughout your CSS, because it's easier to compare hex to hex and decimal to decimal.
 -->
1.
In style.css, find the hex value #8FBC8F and change it to rgb(143, 188, 143).

2.
In style.css, find the hex value #A0522D and change it to rgb(160, 82, 45).

3.
In style.css, find the hex value #8B4513 and change it to rgb(139, 69, 19).

++++++++++++++++++++++++++++++++++++++
CSS COLOR
Hex and RGB

<!-- The hexadecimal and RGB color system can represent many more colors than the small set of CSS named colors. We can use this new set of colors to refine our web page's style.

In both hex and decimal, we have three values, one for each color. Each can be one of 256 values. Specifically, 256 * 256 * 256 = 16,777,216. That is the amount of colors we can now represent. Compare that to the 147 named CSS colors!

Recall that we started with named colors, converted them to hex, and then converted some of the hex colors to decimal. Unless we made a mistake, all of the colors should still be the same, visually. Let's use our broadened palette to make some more refined color choices.
 -->
1.
In the .green rule in style.css, change the background color to #9EB599.

Run the code. Can you tell the difference?

2.
In the .light rule in style.css, change the background color to #683C2C.

3.
In the .city rule in style.css, change the background color to #4C352D.

4.
In the .vienna rule in style.css, change the background color to #352926.

5.
In the .italian rule in style.css, change the background color to #141212.

Run the code one more time. These new colors are a lot closer to the real-life color of each type of coffee. How does the subtle difference feel?

++++++++++++++++++++++++++++++++++
CSS COLOR
Hue, Saturation, and Lightness

<!-- The RGB color scheme is convenient because it's very close to how computers represent colors internally. There's another equally powerful system in CSS called the hue-saturation-lightness color scheme, abbreviated as HSL.

The syntax for HSL is similar to the decimal form of RGB, though it differs in important ways. The first number represents the degree of the hue, and can be between 0 and 360. The second and third numbers are percentages representing saturation and lightness respectively. Here is an example:

color: hsl(120, 60%, 70%);
Hue is the first number. It refers to an angle on a color wheel. Red is 0 degrees, Green is 120 degrees, Blue is 240 degrees, and then back to Red at 360. You can see an example of a color wheel below:

color wheel

Saturation refers to the intensity or purity of the color. If you imagine a line segment drawn from the center of the color wheel to the perimeter, the saturation is a point on that line segment. If you spin that line segment to different angles, you'll see how that saturation looks for different hues. The saturation increases towards 100% as the point gets closer to the edge (the color becomes more rich). The saturation decreases towards 0% as the point gets closer to the center (the color becomes more gray).

Lightness refers to how light or dark the color is. Halfway, or 50%, is normal lightness. Imagine a sliding dimmer on a light switch that starts halfway. Sliding the dimmer up towards 100% makes the color lighter, closer to white. Sliding the dimmer down towards 0% makes the color darker, closer to black.

HSL is convenient for adjusting colors. In RGB, making the color a little darker may affect all three color components. In HSL, that's as easy as changing the lightness value. HSL is also useful for making a set of colors that work well together by selecting various colors that have the same lightness and saturation but different hues.
 -->
1.
In the browser is a simple page with different colored rectangles.

In style.css, modify the lightness of the background color of the class selector .midground to be 25%.

2.
Change the saturation of the background color of the .foreground class selector to 50%.

3.
Change the hue of the body selector's background color to 240 degrees.

++++++++++++++++++++++++++++++++++++
CSS COLOR
Opacity and Alpha

<!-- All of the colors we've seen so far have been opaque, or non-transparent. When we overlap two opaque elements, nothing from the bottom element shows through the top element. In this exercise, we'll change the opacity, or the amount of transparency, of some colors so that some or all of the bottom elements are visible through a covering element.

To use opacity in the HSL color scheme, use hsla instead of hsl, and four values instead of three. For example:

color: hsla(34, 100%, 50%, 0.1);
The first three values work the same as hsl. The fourth value (which we have not seen before) is the alpha. This last value is sometimes called the opacity.

Alpha is a decimal number from zero to one. If alpha is zero, the color will be completely transparent. If alpha is one, the color will be opaque. The value for half transparent would be 0.5.

You can think of the alpha value as, "the amount of the background to mix with the foreground". When a color's alpha is below one, any color behind it will be blended in. The blending happens for each pixel; no blurring occurs.

The RGB color scheme has a similar syntax for opacity, rgba. Again, the first three values work the same as rgb and the last value is the alpha. Here's an example:

color: rgba(234, 45, 98, 0.33);
Alpha can only be used with HSL and RGB colors; we cannot add the alpha value to color: green color: #FFFFF.

There is, however, a named color keyword for zero opacity, transparent. It's equivalent to rgba(0, 0, 0, 0). It's used like any other color keyword:

color: transparent;
 -->

1.
Give the element with class .foreground an alpha value of 0.6. Remember to change hsl to hsla.

2.
Give the element with class .midground an alpha value of 0.4 using hsla.

Run the code, and notice how all the colors blend depending on how they overlap.

3.
Modify the body selector's background color to have a value of rgba(0, 255, 0, 0.5).

4.
Now, set the alpha of the document body to 0.1. How does opacity change the background?

#style.css


html,
body {
  margin: 0;
  height: 100%;
}

.wrapper {
  position: relative;
  margin: auto;
  padding: 0;
  max-width: 75vw;
}

.midground, .foreground {
  position: absolute;
  top: 0;
  left: 0;
  display: inline-block;
  margin: 15vh 0 0 15vw;
  padding: 0;
  width: 35vw;
  height: 59vh;
}

body {
  background-color: rgba(0, 255, 0, 0.1);
}

.midground {
  background-color: hsla(225, 100%, 25%,0.4);
}

.foreground {
  background-color: hsla(325, 50%, 50%, 0.6);
}

---------------------------------------------------------------------------
04/01/2019

CSS TYPOGRAPHY
Typography

<!-- In this lesson, we'll focus on typography, the art of arranging text on a page. In particular, we'll look at how to style fonts with CSS to make them legible and appealing and how to add external fonts to your web pages.

Some of the most important information a user will see on a web page will be textual. Styling text to make page content accessible and engaging can significantly improve user experience. Let's begin!

Instructions
In the browser, we have a blog site with fonts of different sizes and styles. In the following exercises, we'll learn how to manipulate fonts to create engaging interfaces.

Once you have an idea of the general layout of the page, proceed to the next exercise.
 -->

 ++++++++++++++++++++++++++
CSS TYPOGRAPHY
Font Family

<!-- If you've ever used a formatted word processor, chances are that you probably also used a feature that allowed you change the "type of font" you were typing in. The phrase "type of font" refers to the technical term typeface, or font family.

To change the typeface of text on your web page, you can use the font-family property.

h1 {
  font-family: Garamond;
}
In the example above, the font family for all main heading elements has been set to Garamond.

When setting typefaces on a web page, keep the following points in mind:

The font specified in a stylesheet must be installed on a user's computer in order for that font to display when a user visit the web page. We'll learn how to work around this issue in a later exercise.

You've probably noticed that we haven't been specifying a typeface in previous exercises of this course. How exactly does the browser know what typeface to use when displaying the web page? The default typeface for all most browsers is Times New Roman. You may be familiar with this typeface if you have ever used a formatted word processor.

It's a good practice to limit the number of typefaces used on a web page to 2 or 3.

When the name of a typeface consists of more than one word, it must be enclosed in double quotes (otherwise it will not be recognized), like so:

h1 {
  font-family: "Courier New";
}
 -->

1.
In style.css, change the font family of h1 and h2 elements to Georgia.

2.
Next, change the font family of the paragraph to Helvetica.

+++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Font Weight

<!-- You've probably noticed bold text in websites you use, especially in news or text-heavy sites. It's common to bold important headings or keywords. In CSS, we can style bold text with the font-weight property.

If we want to bold text in a web page, we can set the font-weight to bold.

p {
  font-weight: bold;
}
If we want to ensure that text is not bold, we can set the font-weight to normal.

p {
  font-weight: normal;
}
By default, the font-weight of most text elements is set to normal. Some elements, like headers, have built-in bold styling. A good approach is to check to see if the the text element has any default styling, and use the font-weight property accordingly.
 -->
Instructions
1.
Taking a look at the web page in the browser, you'll notice a "Banner" section, the blue section right below the navigation menu.

In style.css, in the banner section of the stylesheets, set the font weight of the paragraph within class banner to bold. You'll notice that the letters in the paragraph in the web page thicken.

+++++++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Font Weight II

<!-- The font-weight property can also be assigned a number value to style text on a numeric scale ranging from 100 to 900. Valid values are multiples of 100 within this range such as 200 or 500.

When using numeric weights, there are a number of default font weights that we can use:

400 is the default font-weight of most text.
700 signifies a bold font-weight.
300 signifies a light font-weight.
Let's take a look at an example of how numeric fonts are used.

header {
  font-weight: 800;
}

footer {
  font-weight: 200;
}
Here, the header would appear as a deep bold, while the footer would appear rather light.

It's important to note that not all fonts can be assigned a numeric font-weight. You can look up the font you are using to see which font-weight values are available.
 -->
Instructions
1.
The header section of the webpage is where the navigation menu is. It lives at the very top of the page.

In style.css, in the header section, set the font weight of the element with class header to 900. You'll notice the list elements in the navigation thicken.

++++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Font Style

<!-- You can also italicize text with the font-style property.

h3 {
  font-style: italic;
}
The italic value causes text to appear in italics. The font-style property also has a normal value which is the default.
 -->
Instructions
1.
The web page features three sections, "Garamond", "Helvetica", and "Space Mono". Each of these sections includes a line with the name of the font creator, such as "Claude Garamond".

Let's italicize the creator's name on each of these cards. In style.css, in the font card section, set the font style of .font-card .creator to italic.

Notice the font change from normal to italic on the web page.

+++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Word Spacing

<!-- You can also increase the spacing between words in a body of text, technically known as word spacing.

To do so, you can use the word-spacing property:

h1 {
  word-spacing: 0.3em;
}
The default amount of space between words is usually 0.25em. In the example above, the word spacing is set to 0.3em, which represents an increase of only .05em in word spacing.

It's not common to increase the spacing between words, but it may help enhance the readability of bolded or enlarged text. Note, again, that the preferred unit is ems.
 -->
Instructions
1.
In style.css, set the word spacing of the h2 elements to 0.05em.

++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Letter Spacing

<!-- You've learned how to increase the spacing between lines of text and words, but it's possible to get even more detailed: increasing the spacing between individual letters.

The technical term for adjusting the spacing between letters is called "kerning". Kerning can be adjusted with the letter-spacing property in CSS.

h1 {
  letter-spacing: 0.3em;
}
Like word spacing, it's not common to increase the kerning in text, but sometimes it enhances the readability of uppercase text.
 -->
Instructions
1.
In style.css, set the letter spacing of the h2 elements to 0.02em.

+++++++++++++++++++++++++++
CSS TYPOGRAPHY
Text Transformation

<!-- Text can also be styled to appear in either all uppercase or lowercase with the text-transform property.

h1 {
  text-transform: uppercase;
}
The code in the example above formats all <h1> elements to appear in uppercase, regardless of the case used for the heading within the HTML code. Alternatively, the lowercase value could be used to format text in all lowercase.

Since text can be directly typed in all uppercase or lowercase within an HTML file, what is the point of a CSS rule that allows you to format letter case?

Depending on the type of content a web page displays, it may make sense to always style a specific element in all uppercase or lowercase letters. For example, a website that reports breaking news may decide to format all <h1> heading elements such that they always appear in all uppercase, as in the example above. It would also avoid uppercase text in the HTML file, which could make code difficult to read.
 -->
Instructions
1.
In style.css, transform the text in the main heading (h1) to appear uppercase.

+++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Text Alignment

<!-- No matter how much styling is applied to text (typeface, size, weight, etc.), text always appears on the left side of the browser.

To move, or align, text, we can use the text-align property.

h1 {
  text-align: right;
}
The text-align property can be set to one of the following three values:

left - aligns text to the left hand side of the browser.
center - centers text.
right - aligns text to the right hand side of the browser.
Later in the course, you'll learn exactly how the browser positions HTML elements by default, which will help you understand how the browser "aligns" text, since "align" is a relative term. For now, it's enough to know that text can be moved to the left, center, or right side of the web page.
 -->
Instructions
1.
In style.css, set the text-align property of the main heading (h1) so that it appears on the left.

2.
On second thought, the heading looks better in the center. Reset the heading so that it is aligned to the center.

+++++++++++++++++++++++++++
CSS TYPOGRAPHY
Line Height Anatomy

<!-- Another property that we can set for text is line-height. This property modifies the leading of text.

The diagram to the right helps illustrate exactly what the terms "leading" and "line height" mean. -->

+++++++++++++++++++++++++
CSS TYPOGRAPHY
Line Height

<!-- We often modify line-height to make text on a web page easier to read. When text is styled to appear larger, the vertical spacing between lines of text can decrease, creating text that is difficult to read, particularly in paragraphs.

We can use the line-height property to set how tall we want the line containing our text to be, regardless of the height of the text. Line heights can take one of several values:

A unitless number, such as 1.2. This number is an absolute value that will compute the line height as a ratio of the font size.
A number specified by unit, such as 12px. This number can be any valid CSS unit, such as pixels, percents, ems, or rems.
Generally, the unitless ratio value is the preferred method, since it is responsive and based exclusively on the current font size. In other words, if we change the font size, a unitless line-height would automatically readjust, whereas the pixel value would remain static.

p {
  line-height: 1.4;
}
 -->

Instructions
1.
Let's change the line height of the text within the banner.

In style.css, set the line height of the paragraph element within the banner class to 1.4. You'll notice the line height increase.

+++++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Serif and Sans Serif

<!-- You've learned a lot of properties to modify text on a web page!

In the next exercise, you'll set some text to be serif and some text to be sans-serif. What exactly do these words mean?

Serif — fonts that have extra details on the ends of each letter. Examples include fonts like Times New Roman or Georgia, among others.

Sans-Serif — fonts that do not have extra details on the ends of each letter. Instead, letters have straight, flat edges, like Arial or Helvetica. -->

Instructions
Notice the difference between serif fonts and sans-serif fonts in the diagram to the right. When you're done, proceed to the next exercise.

+++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Fallback Fonts

<!-- What happens when a stylesheet requires a font that is not installed on a user's computer? Most computers have a small set of typefaces pre-installed. This small set includes serif fonts like Times New Roman and sans-serif fonts like Arial.

These pre-installed fonts serve as fallback fonts if the stylesheet specifies a font which is not installed on a user's computer.

To use fallback fonts, the following syntax is required:

h1 {
  font-family: "Garamond", "Times", serif;
}
The CSS rule above says:

Use the Garamond font for all <h1> elements on the web page.
If Garamond is not available, use the Times font.
If Garamond and Times are not available, use any serif font pre-installed on the user's computer.
The fonts specified after Garamond are the fallback fonts (Times, serif). Fallback fonts help ensure a consistent experience for the diverse audience of users that visit a site.
 -->
Instructions
1.
Below the banner, the web page is made of three main font sections, Serif, Sans-Serif and Monospace. Each of these sections shows an example font, Garamond, Helvetica, and Space Mono, respectively.

We'll focus on styling the Garamond setion here. In style.css, in the "Font Card" section, create the selector .garamond .sample .text.

2.
Using the selector you just created, set the font to Garamond and add serif as a fallback font.

3.
In style.css, below the last selector you made, create the selector .helvetica .sample .text.

4.
Using the selector you just created, set the font to Helvetica and add sans-serif as a fallback font.

++++++++++++++++++++++++++++++++++++++++++++

CSS TYPOGRAPHY
Linking Fonts I

<!-- With the number of fonts available with modern typography, it is unrealistic to expect users to have all fonts installed on their computers. New fonts are often centralized in directories made available for public use. We refer to these fonts as non-user fonts.

Google Fonts is one such directory of thousands of open-source fonts, available for free use. Google Fonts gives us a way to retrieve the link for a single font, multiple fonts, or multiple fonts with the font-weight and font-style properties.

We'll show you where to add this link in the next exercise.
 -->
Instructions
1. View the video in this exercise.

The video demonstrates how to retrieve the link for a single font, multiple fonts, and multiple fonts of various numeric font weights and font styles.



2. Once you have viewed the video, repeat these steps in the browser on your desktop computer, selecting the Space Mono font specifying both the regular (400) and bold (700) font-weights.

When you are ready, click 'Next' to continue.

++++++++++++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Linking Fonts II

<!-- When we have the link to the font of our choice, we can add the font to the <head> section of the HTML document, using the <link> tag and the href.

Let's take a look at a few examples:

1. A single linked font, using Droid Serif as an example:

<head>
  <link href="https://fonts.googleapis.com/css?family=Droid+Serif" type="text/css" rel="stylesheet">
</head>


2. Multiple linked fonts, using the Droid Serif and Playfair Display fonts as an example:

<head>
  <link href="https://fonts.googleapis.com/css?family=Droid+Serif|Playfair+Display" type="text/css" rel="stylesheet">
</head>


3. Multiple linked fonts, along with weights and styles. Here Droid Serif has font weights of 400, 700, and 700i, while Playfair Display has font weights of 400, 700, and 900i:

<head>
  <link href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700,700i|Playfair+Display:400,700,900i" rel="stylesheet">
</head>


Once a font is linked, we can create CSS selectors to target elements, just as we do with other fonts.
 -->
Instructions
1.
In the previous exercise, you surfaced the link to the Space Mono font specifying both the normal (400) and bold (700) font weights.

In index.html include this font in the project using the <link> tag.

The url to reference in the the link tag is:

https://fonts.googleapis.com/css?family=Space+Mono:400,700
2.
In style.css, in the "Font Card" section, create the selector .space .sample .text.

3.
Using the selector you just created, set the font to "Space Mono" and add monospace as a fallback font.

++++++++++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Font-Face I

<!-- There are other ways to link non-user fonts that don't require the use of the <link> tag in the HTML document. CSS offers a way to import fonts directly into stylesheets with the @font-face property.

To load fonts with the @font-face property:

Instead of using the font's link in the HTML document, enter the link into the URL bar in the browser.
The browser will load the CSS rules. You will need to focus on the rules that are directly labeled as /* latin */. Some of the latin rules are on separate lines. You will need each of these.
Copy each of the CSS rules labeled latin, and paste the rules from the browser to the top of style.css.
It is important to stress the need to copy the @font-face rules to the top of the stylesheet for the font to load correctly in the project.
 -->
Instructions
1. View the video in this exercise.

The video demonstrates how to enter the Space Mono font link you previously retrieved into the browser. The browser in turn displays the rules you will use for the font.



2. Once you have viewed the video, repeat these steps in the browser on your desktop computer, with link for the Space Mono font with normal (400) and bold (700) font-weights. You can find the direct link to the font here.

Once your desktop browser displays the rules, click 'Next' to continue.

++++++++++++++++++++++++++++++++++
CSS TYPOGRAPHY
Font-Face II

<!-- We can then use the fonts in the stylesheets as you would use any other font. Let's practice loading an external font in our stylesheets using the @font-face property, and using the font to style our page.
 -->
Instructions
1.
In index.html remove the link to the Space Mono font that you added in the previous exercise.

2.
Now, add this same font to style.css using the @font-face rules labeled latin.

Recall that in order to do this, we use the same CSS rules returned in the browser for the Space Mono font, and copy the latin @font-face rules to the top of the stylesheet.

If you need help retrieving the link for the appropriate font, click here.

Once you add the font, you'll notice that the elements styled in the Space Mono font retain the correct font styling.

+++++++++++++++++++++++++++++++

CSS TYPOGRAPHY
Font-Face III

<!-- While Google Fonts and other resources can broaden font selection, you may wish to use an entirely different font or abstain from using a font from an external service.

We can modify our @font-face rule to use local font files as well. We can supply the user with the desired font family and host it along with our site instead of depending on a different site.

@font-face {
  font-family: "Roboto";
  src: url(fonts/Roboto.woff2) format('woff2'),
       url(fonts/Roboto.woff) format('woff'),
       url(fonts/Roboto.tff) format('truetype');
}
Here, you'll notice:

The main difference is the use of a relative filepath instead of a web URL.

We add a format for each file to specify which font to use. Different browsers support different font types, so providing multiple font file options will support more browsers.

As of now .woff2 appears to be the way of the future, due to greatly reduced file sizes and improved performance, but many browsers still don’t support it. There are lots of great sources to find fonts to use locally, such as Font Squirrel.
 -->
Instructions
1.
In the fonts/ directory, you'll notice that we have added several local font files.

Let's change the typography of the banner, using local font files. If you open up the fonts/ directory using the file navigator in the code editor, you'll notice that we have added local font files Glegoo-Regular.ttf and Glegoo-Bold.ttf.

At the top of style.css, create a selector using the @font-face property and give it the font family Glegoo.

2.
Within the @font-face rule, add a src attribute with the relative path of the file Glegoo-Regular.ttf and a format of truetype. Make sure to include this path in the url() parentheses.

3.
Using the selector that targets the paragraph nested within the banner class, add the font family Glegoo and a font size of 20px.

Reload the page to see the changes in the browser.

=====================================
#style.css

@font-face {
  font-family:"Glegoo";
  src: url("../fonts/Glegoo-Regular.ttf") format("truetype");
}

@font-face {
  font-family: 'Space Mono';
  font-style: normal;
  font-weight: 400;
  src: local('Space Mono'), local('SpaceMono-Regular'), url(https://fonts.gstatic.com/s/spacemono/v1/adVweg3BJhE6r8jYmXseHQzyDMXhdD8sAj6OAJTFsBI.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}

@font-face {
  font-family: 'Space Mono';
  font-style: normal;
  font-weight: 700;
  src: local('Space Mono Bold'), local('SpaceMono-Bold'), url(https://fonts.gstatic.com/s/spacemono/v1/vdpMRWfyjfCvDYTz00NEPGaVI6zN22yiurzcBKxPjFE.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}

html {
  font-size: 16px;
  font-family: "Arial", sans-serif;
}

body {
  background-color: #F2F2F2;
}

h1 {
  color: white;
  font-size: 28px;
  font-family: Georgia;
  text-transform: uppercase;
}

h2 {
  font-size: 24px;
  font-weight: 700;
  line-height: 2.5;
  font-family: Georgia;
  word-spacing: 0.05em;
  letter-spacing: 0.02em;
}

a {
  text-decoration: none;
}

p {
  margin: 16px 0;
  font-family: Helvetica;
}

strong {
  font-weight: bold;
}

#serif, /* Offset linked sections to account for header. */
#sans,
#mono {
  padding-top: 77px;
  margin-top: -77px;
}

/* Header */

.header {
  font-family: "Arial", sans-serif;
  font-size: 14px;
  line-height: 1.25;
  background-color: #fff;
  position: fixed;
  top: 0;
  width: 100%;
  font-weight: 900;
}

.header li {
  display: inline-block;
}

.header a {
  display: block;
  color: #4A4A4A;
  padding: 30px 20px;
}

a.home {
  color: #4D00FF;
}


/* Banner Section */

.banner {
  background-color: #4D00FF;
  padding: 100px 0;
  margin-top: 77px;
  text-align: center;
}

.banner p {
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
  padding: 10px;
  color: #ffffff;
  font-weight: bold;
  line-height: 1.4;
  font-family: "Glegoo";
  font-size: 20px;
}

/* Editorial Sections */

.editorial {
  padding: 20px;
  margin: 20px 0;
  text-align: center;
  color: #4C4C4C;
}

/* Font Card Sections */

.font-card {
  background-color: #ffffff;
  margin: 50px 0;
  padding: 20px 50px;
}

.font-card .creator {
  font-size: 20px;
  line-height: 1.25;
  font-style: italic;
}

.sample {
  display: inline-block;
  padding: 0 20px;
  margin: 20px;
}

.sample h2 {
  line-height: 1.5;
}

.sample .text {
  color: #4D00FF;
  font-size: 100px;
}

/* Add styles for the Garamond font here */

.garamond .sample .text {
  font-family: Garamond, serif;
}

/* Add styles for the Helvetica font here */

.helvetica .sample .text {
  font-family: Helvetica, sans-serif;
}

/* Add styles for the Space Mono font here */

.space .sample .text {
  font-family: "Space Mono", monospace;
}

.bold {
  font-weight: 900;
}

.regular {
  font-weight: normal;
}

.italic {
  font-weight: normal;
  font-style: italic;
}

/* Media Queries */

@media only screen and (max-width: 535px) {
  .header {
    font-size: 14px;
  }

  .header a {
    padding: 30px 20px;
  }

  a.home {
    display: none;
  }
}


----------------------------------------------------------
SIZING ELEMENTS
Relative Measurements

<!-- Modern technology allows users to browse the Internet via multiple devices, such as desktop monitors, mobile phones, tablets, and more. Devices of different screen sizes, however, pose a problem for web developers: how can we ensure that a website is readable and visually appealing across all devices, regardless of screen size?

The answer: responsive design! Responsive design refers to the ability of a website to resize and reorganize its content based on:

The size of other content on the website.
The size of the screen the website is being viewed on.
In this lesson, we'll size HTML content relative to other content on a website.

You've probably noticed the unit of pixels, or px, used in websites. Pixels are used to size content to exact dimensions. For example, if you want a div to be exactly 500 pixels wide and 100 pixels tall, then the unit of px can be used. Pixels, however, are fixed, hard coded values. When a screen size changes (like switching from landscape to portrait view on a phone), elements sized with pixels can appear too small, overflow the screen, or become completely illegible.

With CSS, you can avoid hard coded measurements and use relative measurements instead. Relative measurements offer an advantage over hard coded measurements, as they allow for the proportions of a website to remain intact regardless of screen size or layout.
 -->
Instructions
The website in the browser to the right uses many relative measurements. Resize the page by increasing and decreasing the browser's width repeatedly. What do you notice about how the content on the page responds to the changes in width?

When you're done resizing the browser component, proceed to the next exercise.

+++++++++++++++++++++++++++
SIZING ELEMENTS
Em

<!-- Incorporating relative sizing starts by using units other than pixels. One unit of measurement you can use in CSS to create relatively-sized content is the em, written as em in CSS.

Historically, the em represented the width of a capital letter M in the typeface and size being used. That is no longer the case.

Today, the em represents the size of the base font being used. For example, if the base font of a browser is 16 pixels (which is normally the default size of text in a browser), then 1 em is equal to 16 pixels. 2 ems would equal 32 pixels, and so on.

Let's take a look at two examples that show how em can be used in CSS.

.heading {
  font-size: 2em;
}
In the example above, no base font has been specified, therefore the font size of the heading element will be set relative to the default font size of the browser. Assuming the default font size is 16 pixels, then the font size of the heading element will be 32 pixels.

.splash-section {
  font-size: 18px;
}

.splash-section h1 {
  font-size: 1.5em;
}
The example above shows how to use ems without relying on the default font size of the browser. Instead, a base font size (18px) is defined for all text within the splash-section element. The second CSS rule will set the font size of all h1 elements inside of splash-section relative to the base font of splash-section (18 pixels). The resulting font size of h1 elements will be 27 pixels.
 -->
Instructions
1.
In style.css, set the font size in #banner h1 ("Bana's Travel Blog") to 1.5em.

2.
Set the font size in .post h2 ("Saturday Market") to 1.75em.

3.
Set the font size in .post h3 to 1.25em.

4.
Set the font size in the footer ("© Bana's Travel Blog") to 0.75em.

++++++++++++++++++++++++++++++++++
SIZING ELEMENTS
Rem

<!-- The second relative unit of measurement in CSS is the rem, coded as rem.

Rem stands for root em. It acts similar to em, but instead of checking parent elements to size font, it checks the root element. The root element is the <html> tag.

Most browsers set the font size of <html> to 16 pixels, so by default rem measurements will be compared to that value. To set a different font size for the root element, you can add a CSS rule.

html {
  font-size: 20px;
}

h1 {
  font-size: 2rem;
}
In the example above, the font size of the root element, <html>, is set to 20 pixels. All subsequent rem measurements will now be compared to that value and the size of h1 elements in the example will be 40 pixels.

One advantage of using rems is that all elements are compared to the same font size value, making it easy to predict how large or small font will appear. If you are interested in sizing elements consistently across an entire website, the rem measurement is the best unit for the job. If you're interested in sizing elements in comparison to other elements nearby, then the em unit would be better suited for the job.
 -->
Instructions
1.
In style.css, add a new rule on line 3 that sets the font size of the root element to 16 pixels.

2.
Let's update the font sizes you set in the previous exercise to use rem instead of em.

First, change the font size in #banner h1 to 3.75rem.

3.
Set the font size in .post h2 to 1.875rem.

4.
Set the font size in .post h3 to 1.125rem.

5.
Set the font size of the footer to 1.125rem.

+++++++++++++++++++++++++++++++++++++++++++
SIZING ELEMENTS
Percentages: Height & Width

<!-- To size non-text HTML elements relative to their parent elements on the page you can use percentages.

Percentages are often used to size box-model values, like width and height, padding, border, and margins. They can also be used to set positioning properties (top, bottom, left, right).

To start, let's size the height and width of an element using percentages.

.main {
  height: 300px;
  width: 500px;
}

.main .subsection {
  height: 50%;
  width: 50%;
}
In the example above, .main and .subsection each represent divs. The .subsection div is nested within the .main div. Note that the dimensions of the parent div (.main) have been set to a height of 300 pixels and a width of 500 pixels.

When percentages are used, elements are sized relative to the dimensions of their parent element (also known as a container). Therefore, the dimensions of the .subsection div will be 150 pixels tall and 250 pixels wide. Be careful, a child element's dimensions may be set erroneously if the dimensions of its parent element aren't set first.

Note: Because the box model includes padding, borders, and margins, setting an element's width to 100% may cause content to overflow its parent container. While tempting, 100% should only be used when content will not have padding, border, or margin.

 -->Instructions
1.
Currently, the blog takes up the full width of the body. Let's modify this so that it doesn't extend to fill the full width.

In style.css, set the width in #blog to 86%.

This will responsively set the entire blog's container to 86% of the full width of the body.

2.
Great! Resize the browser's width again. Notice that the blog's text becomes illegible at smaller widths.

To fix this, set the width in #blog .post to 52%.

This will ensure that the text fills only 52% of its container's (#blog) width. Resize the browser now and notice how the text remains legible.

3.
Now set the width in .post .image-container to 100%. This will make sure the image's container is always the full width of the blog post (.post).

4.
Scroll to the bottom of the web page. Notice that there are two images. We'd like to display these images next to each other on the page, with equal width.

Set the width in .images .image-container to 50%. This will give each image in .images equal width.

--------------------------------------------------
SIZING ELEMENTS
Percentages: Padding & Margin

<!-- Percentages can also be used to set the padding and margin of elements.

When height and width are set using percentages, you learned that the dimensions of child elements are calculated based on the dimensions of the parent element.

When percentages are used to set padding and margin, however, they are calculated based only on the width of the parent element.

For example, when a property like margin-left is set using a percentage (say 50%), the element will be moved halfway to the right in the parent container (as opposed to the child element receiving a margin half of its parent's margin).

Vertical padding and margin are also calculated based on the width of the parent. Why? Consider the following scenario:

A container div is defined, but its height is not set (meaning it's flat).
The container then has a child element added within. The child element does have a set height. This causes the height of its parent container to stretch to that height.
The child element requires a change, and its height is modified. This causes the parent container's height to also stretch to the new height. This cycle occurs endlessly whenever the child element's height is changed!
In the scenario above, an unset height (the parent's) results in a constantly changing height due to changes to the child element. This is why vertical padding and margin are based on the width of the parent, and not the height.

Note: When using relative sizing, ems and rems should be used to size text and dimensions on the page related to text size (i.e. padding around text). This creates a consistent layout based on text size. Otherwise, percentages should be used.
 -->
Instructions
1.
Let's size the height of the banner relative to the root element's font size.

In style.css, for the #banner ruleset, add a height property and assign it to 46rem.

Note: The root element's font size is 16 pixels, meaning that 46rem will result in a height of 736 pixels.

2.
Set the top margin in #blog .post to 12.5%.

3.
Set the bottom margin in #blog .post to 7.5%.

4.
Set the bottom margin in .images to 20%.
Don't worry if the images still look distorted at the moment. You'll improve their appearance in a later exercise.

++++++++++++++++++++++++++++++++++++
SIZING ELEMENTS
Width: Minimum & Maximum

<!-- Although relative measurements provide consistent layouts across devices of different screen sizes, elements on a website can lose their integrity when they become too small or large. You can limit how wide an element becomes with the following properties:

min-width — ensures a minimum width for an element.
max-width — ensures a maximum width for an element.
p {
  min-width: 300px;
  max-width: 600px;
}
In the example above, when the browser is resized, the width of paragraph elements will not fall below 300 pixels, nor will their width exceed 600 pixels.

When a browser window is narrowed or widened, text can become either very compressed or very spread out, making it difficult to read. These two properties ensure that content is legible by limiting the minimum and maximum widths.

Note: The unit of pixels is used to ensure hard limits on the dimensions of the element(s).
 -->
Instructions
1.
Resize the browser to the right. Notice that the text on the web page can become difficult to read. Let's limit the text's width to keep it legible.

In style.css, create a CSS rule that sets the minimum width of all paragraphs to 200 pixels and run your code.

Now, resize your browser (make it narrower) and notice that the text no longer compresses as much as it did before.

++++++++++++++++++++++++++++++++++++++
SIZING ELEMENTS
Height: Minimum & Maximum

<!-- You can also limit the minimum and maximum height of an element.

min-height — ensures a minimum height for an element's box.
max-height — ensures a maximum height for an element's box.
p {
  min-height: 150px;
  max-height: 300px;
}
In the example above, the height of all paragraphs will not shrink below 150 pixels and the height will not exceed 300 pixels.

What will happen to the contents of an element if the max-height property is set too low for that element? It's possible that content will overflow outside of the element, resulting in content that is not legible.
 -->
Instructions
1.
Again, resize your browser (stretch it out). Notice that the paragraph's text can become overly spread out (i.e. a small height). Let's limit the height to keep the text legible.

In style.css, set the minimum height of all paragraphs to 200 pixels.

Resize your browser once more and notice that the text no longer spreads out as much as it did before.

+++++++++++++++++++++++++++++++++++++
SIZING ELEMENTS
Scaling Images and Videos

<!-- Many websites contain a variety of different media, like images and videos. When a website contains such media, it's important to make sure that it is scaled proportionally so that users can correctly view it.

.container {
  width: 50%;
  height: 200px;
  overflow: hidden;
}

.container img {
  max-width: 100%;
  height: auto;
  display: block;
}
In the example above, .container represents a container div. It is set to a width of 50% (half of the browser's width, in this example) and a height of 200 pixels. Setting overflow to hidden ensures that any content with dimensions larger than the container will be hidden from view.

The second CSS rule ensures that images scale with the width of the container. The height property is set to auto, meaning an image's height will automatically scale proportionally with the width. Finally, the last line will display images as block level elements (rather than inline-block, their default state). This will prevent images from attempting to align with other content on the page (like text), which can add unintended margin to the images.

It's worth memorizing the entire example above. It represents a very common design pattern used to scale images and videos proportionally.

Note: The example above scales the width of an image (or video) to the width of a container. If the image is larger than the container, the vertical portion of the image will overflow and will not display. To swap this behavior, you can set max-height to 100% and width to auto (essentially swapping the values). This will scale the height of the image with the height of the container instead. If the image is larger than the container, the horizontal portion of the image will overflow and not display.
 -->
Instructions
1.
Take a look at the images on the web page. Notice that they currently display incorrectly (too large). Let's fix that.

First, in style.css, set the overflow property in .image-container to hidden. Run your code.

Take a look at the images once more. At this point, the images partially display. In reality, what we've done is constrain them to the dimensions of their container (.image-container). Any part of the image that overflows out of the container will be hidden from view. This will set us up to scale them proportionally.

2.
Resize the width of the browser back and forth. Notice that the images expand and contract to show more (or less) of the image. Instead, let's display the full image at all times.

In style.css, set the maximum width in .image-container img to 100%. This will ensure the full image is always displayed.

3.
Great work! Take a look at the images on the web page again — they have been greatly improved!

Next, we'll want to make sure the images automatically remain in proportion when the browser is resized.

In .image-container img, set the height to auto.

4.
Finally, within the same CSS rule, set the display to block. This will instruct the images to behave as block-level elements and facilitate scaling (as opposed to their default inline behavior).

+++++++++++++++++++++++++++++++
SIZING ELEMENTS
Scaling Background Images

<!-- Background images of HTML elements can also be scaled responsively using CSS properties.

body {
  background-image: url('#');
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover;
}
In the example above, the first CSS declaration sets the background image (# is a placeholder for an image URL in this example). The second declaration instructs the CSS compiler to not repeat the image (by default, images will repeat). The third declaration centers the image within the element.

The final declaration, however, is the focus of the example above. It's what scales the background image. The image will cover the entire background of the element, all while keeping the image in proportion. If the dimensions of the image exceed the dimensions of the container then only a portion of the image will display.
 -->
Instructions
1.
In style.css, set the background-size property in #banner to cover.

-------------------------------------------------------------------------
MEDIA QUERIES
Responsive Web Design

<!-- When someone visits a website, it's possible they are viewing it on a phone, tablet, computer, or even a TV monitor. Because screen sizes can vary greatly across different devices, it's important for websites to resize and reorganize their content to best fit screens of all sizes.

When a website doesn't respond to different screen sizes, the website may look odd or become indecipherable on certain devices. This usually occurs on smaller screens, like phones. When a website responds to the size of the screen it's viewed on, it’s called a responsive website.

Because websites can be displayed on thousands of different screen sizes, they must be able to respond to a change in screen size and adapt the content so that users can access it.

 -->Let's take a look at a website that does not respond to different screen sizes.

First, visit this site.
Then resize the width of your browser to simulate a smaller screen size. Note how the content on the web page does not shrink as you resize the browser's width.
In contrast, let's take a look at a responsive website.

First, visit this site.
Again, resize the width of your browser and note how the content on the web page resizes and reorganizes itself.

++++++++++++++++++++++++++++++++++++++++++
MEDIA QUERIES
Media Queries

<!-- CSS uses media queries to adapt a website's content to different screen sizes. With media queries, CSS can detect the size of the current screen and apply different CSS styles depending on the width of the screen.

@media only screen and (max-width: 480px) {
  body {
    font-size: 12px;
  }
}
The example above demonstrates how a media query is applied. The media query defines a rule for screens smaller than 480 pixels (approximately the width of many smartphones in landscape orientation).

Let’s break this example down into its parts:

@media — This keyword begins a media query rule and instructs the CSS compiler on how to parse the rest of the rule.
only screen — Indicates what types of devices should use this rule. In early attempts to target different devices, CSS incorporated different media types (screen, print, handheld). The rationale was that by knowing the media type, the proper CSS rules could be applied. However, “handheld” and “screen” devices began to occupy a much wider range of sizes and having only one CSS rule per media device was not sufficient. screen is the media type always used for displaying content, no matter the type of device. The only keyword is added to indicate that this rule only applies to one media type (screen).
and (max-width : 480px) — This part of the rule is called a media feature, and instructs the CSS compiler to apply the CSS styles to devices with a width of 480 pixels or smaller. Media features are the conditions that must be met in order to render the CSS within a media query.
CSS rules are nested inside of the media query's curly braces. The rules will be applied when the media query is met. In the example above, the text in the body element is set to a font-size of 12px when the user's screen is less than 480px.
 -->Instructions
1.
At the bottom of style.css, write a media query for a max-width of 480px.

This will allow us to shrink the width of the .page-title element on smaller screens.

2.
When the screen is less than 480px wide, give the .page-title class a width of 270px.

This will make the .page-title element appear more clearly on small screens. Test your code by resizing the browser.

+++++++++++++++++++++++++++++++++++++++++++
MEDIA QUERIES
Range

<!-- Specific screen sizes can be targeted by setting multiple width and height media features. min-width and min-height are used to set the minimum width and minimum height, respectively. Conversely, max-width and max-height set the maximum width and maximum height, respectively.

By using multiple widths and heights, a range can be set for a media query.

@media only screen and (min-width: 320px) and (max-width: 480px) {
    /* ruleset for 320px - 480px */
}
The example above would apply its CSS rules only when the screen size is between 320 pixels and 480 pixels. Notice the use of a second and keyword after the min-width media feature. This allows us to chain two requirements together.

The example above can be written using two separate rules as well:

@media only screen and (min-width: 320px) { 
    /* ruleset for 320px - 479px */
}


@media only screen and (min-width: 480px) { 
    /* ruleset for > 480px */
}
The first media query in the example above will apply CSS rules when the size of the screen meets or exceeds 320 pixels. The second media query will apply CSS rules when the size of the screen meets or exceeds 480 pixels, meaning that it will override the CSS rules present in the first media query.

Both examples above are valid, and it is likely that you will see both patterns used when reading another developer's code.
 -->
Instructions
1.
Let's make the gallery images appear larger when the screen size is small to medium size.

Write one @media query for screen sizes with a range between 320px and 480px. Use min-width and max-width to define the range.

2.
Inside the media query, select the thumbnails within the gallery with .gallery-item .thumbnail and give them a width of 95%.

You should notice that the gallery images appear wider when the screen size is between 320 and 480 pixels wide.

+++++++++++++++++++++++++++++++++++++++++++++
MEDIA QUERIES
Dots Per Inch (DPI)

<!-- Another media feature we can target is screen resolution. Many times we will want to supply higher quality media (images, video, etc.) only to users with screens that can support high resolution media. Targeting screen resolution also helps users avoid downloading high resolution (large file size) images that their screen may not be able to properly display.

To target by resolution, we can use the min-resolution and max-resolution media features. These media features accept a resolution value in either dots per inch (dpi) or dots per centimeter (dpc). Learn more about resolution measurements here.

@media only screen and (min-resolution: 300dpi) {
    /* CSS for high resolution screens */
}
The media query in the example above targets high resolution screens by making sure the screen resolution is at least 300 dots per inch. If the screen resolution query is met, then we can use CSS to display high resolution images and other media.
 -->
Instructions
1.
Write a media query to make the logo higher quality if the visitor is looking at the Amazing Space website on a high resolution display.

A high resolution display may have a min-resolution of 150dpi.

2.
Inside of the media query, add this CSS property to the .logo class:

background-image: url("../img/spaceship@2x.png");
This code will exchange the existing logo with a higher resolution logo. To make the difference obvious, the higher resolution spaceship logo has blue wings.

If you are accessing Codecademy on a screen with a resolution greater than 150dpi, you will observe the spaceship change. If not, you can re-write the min-resolution media feature to a lower value to observe the change.

++++++++++++++++++++++++++++++++++++++++++++
MEDIA QUERIES
And Operator

<!-- In previous exercises, we chained multiple media features of the same type in one media query by using the and operator. It allowed us to create a range by using min-width and max-width in the same media query.

The and operator can be used to require multiple media features. Therefore, we can use the and operator to require both a max-width of 480px and to have a min-resolution of 300dpi.

For example:

@media only screen and (max-width: 480px) and (min-resolution: 300dpi) {
    /* CSS ruleset */
}
By placing the and operator between the two media features, the browser will require both media features to be true before it renders the CSS within the media query. The and operator can be used to chain as many media features as necessary.
 -->
Instructions
1.
The website's text needs to be larger for users who have small, low resolution screens.

Write a media query that applies when the max-resolution is 150dpi and the screen has a max-width of 480px.

2.
Inside the media query, make the font-size of the .page-description element 20px.

+++++++++++++++++++++++++++++++++++++++++++
MEDIA QUERIES
Comma Separated List

<!-- If only one of multiple media features in a media query must be met, media features can be separated in a comma separated list.

For example, if we needed to apply a style when only one of the below is true:

The screen is more than 480 pixels wide
The screen is in landscape mode
We could write:

@media only screen and (min-width: 480px), (orientation: landscape) {
    /* CSS ruleset */
}
In the example above, we used a comma (,) to separate multiple rules. The example above requires only one of the media features to be true for its CSS to apply.

Note that the second media feature is orientation. The orientation media feature detects if the page has more width than height. If a page is wider, it's considered landscape, and if a page is taller, it's considered portrait.
 -->
Instructions
1.
Navigate to the first media query where you targeted screens with a min-width of 320px and a max-width of 480px.

Let's also make the logo and text appear vertical if the screen is in a portrait orientation.

Add another media feature to the rule, using a comma (,) to separate rules. The second media feature should check if the screen's orientation is portrait.

++++++++++++++++++++++++++++++++++++++++++++++

MEDIA QUERIES
Breakpoints

<!-- We know how to use media queries to apply CSS rules based on screen size and resolution, but how do we determine what queries to set?

The points at which media queries are set are called breakpoints. Breakpoints are the screen sizes at which your web page does not appear properly. For example, if we want to target tablets that are in landscape orientation, we can create the following breakpoint:

@media only screen and (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
    /* CSS ruleset */
}
The example above creates a screen size range the size of a tablet in landscape mode and also identifies the orientation.

However, setting breakpoints for every device imaginable would be incredibly difficult because there are many devices of differing shapes and sizes. In addition, new devices are released with new screen sizes every year.

Rather than set breakpoints based on specific devices, the best practice is to resize your browser to view where the website naturally breaks based on its content. The dimensions at which the layout breaks or looks odd become your media query breakpoints. Within those breakpoints, we can adjust the CSS to make the page resize and reorganize.

By observing the dimensions at which a website naturally breaks, you can set media query breakpoints that create the best possible user experience on a project by project basis, rather than forcing every project to fit a certain screen size. Different projects have different needs, and creating a responsive design should be no different.

Check out this list of breakpoints by device widths. Use it as a reference of screen widths to test your website to make certain it looks great across a variety of devices.
 -->
Instructions
1.
The last breakpoint we'd like to account for is a tablet in landscape orientation. The Amazing Space website should change its format to show the gallery pictures on the right, while having the logo and the description on the left.

Write a media query that meets the following requirements:

The screen has a min-width of 768px
The screen has a max-width of 1024px
The screen has an orientation of landscape
2.
Inside of the media query, include this CSS:

.page-title, .page-description {
  float: left;
    width: 20em;
}

.page-description {
    text-align: left;
}
This CSS will make the page title and description float to the left of the gallery images. Resize the browser to observe these changes at various screen widths.

-----------------------------------------------------------------
05/01/2019

FLEXBOX
What is Flexbox?

<!-- CSS provides many tools and properties that you can use to position elements on a webpage. Codecademy's lessons on the box model and CSS display introduce a couple of these techniques.

In this lesson, you will learn about flexbox or Flexible Box Layout, a new tool developed for CSS3 that greatly simplifies how to position elements. While flexbox is not meant to lay out entire pages, it is useful for positioning elements, whether individually or in groups.

There are two important components to a flexbox layout: flex containers and flex items. A flex container is an element on a page that contains flex items. All direct child elements of a flex container are flex items. This distinction is important because some of the properties you will learn in this lesson apply to flex containers while others apply to flex items.

To designate an element as a flex container, set the element's display property to flex or inline-flex. Once an item is a flex container, there are several properties we can use to specify how its children behave. In this lesson we will cover these properties:

justify-content
align-items
flex-grow
flex-shrink
flex-basis
flex
flex-wrap
align-content
flex-direction
flex-flow
Flexbox is an elegant tool that makes it easy to address positioning issues that may have been difficult before. Let's get started!
 -->
Instructions
In the browser to the right, scroll down until you see the phrase "Our Expertise" in the div with the yellow background. Stretch and shrink the browser and observe what happens to the elements.

+++++++++++++++++++++++++++
FLEXBOX
display: flex

<!-- Any element can be a flex container. Flex containers are helpful tools for creating websites that respond to changes in screen sizes. Child elements of flex containers will change size and location in response to the size and position of their parent container.

For an element to become a flex container, its display property must be set to flex.

div.container {
  display: flex;
}
In the example above, all divs with the class container are flex containers. If they have children, the children are flex items. A div with the declaration display: flex; will remain block level — no other elements will appear on the same line as it.

However, it will change the behavior of its child elements. Child elements will not begin on new lines. In the exercises that follow, we will cover how the flex display property impacts the positioning of child elements.
 -->
Instructions
1.
Change the display of the div with id flex to have the value flex. Compare the two divs in the browser.

++++++++++++++++++++++++++++++++++++
FLEXBOX
inline-flex

<!-- In the previous exercise, you might have observed that when we gave a div — a block level element — the display value of flex that it remained a block level element. What if we want multiple flex containers to display inline with each other?

If we didn't want div elements to be block-level elements, we would use display: inline. Flexbox, however, provides the inline-flex value for the display attribute, which allows us to create flex containers that are also inline elements.

<div class="container">
  <p>I’m inside of a flex container!</p>
  <p>A flex container’s children are flex items!</p>
</div>
<div class="container">
  <p>I’m also a flex item!</p>
  <p>Me too!</p>
</div>
.container {
  width: 200px;
  height: 200px;
  display: inline-flex;
}
In the example above, there are two container divs. Without a width, each div would stretch the entire width of the page. The paragraphs within each div would also display on top of each other because paragraphs are block-level elements.

When we change the value of the display property to inline-flex, the divs will display inline with each other if the page is wide enough. As we progress through this lesson, we will cover in more detail how flex items are displayed.

Notice that in the example above, the size of the flex container is set. Currently, the size of the parent container will override the size of its child elements. If the parent element is too small, the flex items will shrink to accommodate the parent container's size. We’ll explain why in a later exercise.

<div class="container">
  <div class="child">
    <h1>1</h1>
  </div>
  <div class="child">
    <h1>2</h1>
  </div>
</div>
.container {
  width: 200px;
}

.child {
  display: inline-flex;
  width: 150px;
  height: auto;
}
In the example above, the .child divs will take up more width (300 pixels) than the container div allows (200 pixels). The .child divs will shrink to accommodate the container's size. In later exercises, we will explore several ways to handle this. -->

Instructions
1.
Set the display property of the .container div to inline-flex.

++++++++++++++++++++++++++++++++++++++
FLEXBOX
justify-content

<!-- In previous exercises, when we changed the display value of parent containers to flex or inline-flex, all of the child elements (flex items) moved toward the upper left corner of the parent container. This is the default behavior of flex containers and their children. We can specify how flex items spread out from left to right, along the main axis. We will learn more about axes in a later exercise.

To position the items from left to right, we use a property called justify-content.

.container {
  display: flex;
  justify-content: flex-end;
}
In the example above, we set the value of justify-content to flex-end. This will cause all of the flex items to shift to the right side of the flex container.

There are five values for the justify-content property:

flex-start — all items will be positioned in order starting, from the left of the parent container, with no extra space between or before them.
flex-end — all items will be positioned in order, with the last item starting on the right side of the parent container, with no extra space between or after them.
center — all items will be positioned in order, in the center of the parent container with no extra space before, between, or after them.
space-around — items will be positioned with equal space before and after each item, resulting in double the space between elements.
space-between — items will be positioned with equal space between them, but no extra space before the first or after the last elements.
In the definitions above, "no extra space" means that margins and borders will be respected, but no more space (than is specified in the style rule for the particular element) will be added between elements. The size of each individual flex item is not changed by this property.
 -->
1.
Assign the div with id #flexstart a justify-content value of flex-start.

2.
Assign the div with id #flexend to have a justify-content value of flex-end.

3.
Assign the div with id #center to have a justify-content value of center.

4.
Assign the div with id #spacearound to have a justify-content value of space-around. Stretch and shrink the browser window to compare and contrast how the elements in each div behave.

5.
Assign the div with id #spacebetween to have a justify-content value of space-between.

+++++++++++++++++++++++++++++++++++

FLEXBOX
align-items


<!-- In the previous exercise, you learned how to justify the content of a flex container from left to right across the page. It is also possible to align flex items vertically within the container. The align-items property makes it possible to space flex items vertically.

.container {
  align-items: baseline;
}
In the example above, the align-items property is set to baseline

There are five values we can use for the align-items property:

flex-start — all elements will be positioned at the top of the parent container.
flex-end — all elements will be positioned at the bottom of the parent container.
center — the center of all elements will be positioned halfway between the top and bottom of the parent container.
baseline — the bottom of the content of all items will be aligned with each other.
stretch — if possible, the items will stretch from top to bottom of the container (this is the default value; elements with a specified height will not stretch; elements with a minimum height or no height specified will stretch).
These five values tell the elements how to behave along the cross axis

You might be unfamiliar with the min-height and max-height properties, but you have used height and width before. min-height, max-height, min-width, and max-width are properties that ensure an element is at least a certain size or at most a certain size. You’ll see how these become useful as you move throughout this lesson.

Now you’re going to see each of the five values above in action!
 -->
1.
Assign the div with the id #flexstart an align-items value of flex-start.

2
Assign the div with the id #flexend an align-items value of flex-end.

3
Assign the div with the id #center an align-items value of center.

4
Assign the div with the id #baseline an align-items value of baseline. How does the behavior of these elements differ from those in other divs?

5.
Change the height property of the .left, .right, and .center divs to be min-height and pay close attention to what happens to the #stretch div.

++++++++++++++++++++++++++++++++++

FLEXBOX
flex-grow

<!-- In Exercise 3, we learned that all flex items shrink proportionally when the flex container is too small. However, if the parent container is larger than necessary then the flex items will not stretch by default. The flex-grow property allows us to specify if items should grow to fill a container and also which items should grow proportionally more or less than others.

<div class="container">
  <div class="side">
    <h1>I’m on the side of the flex container!</h1>
  </div>
  <div class="center">
    <h1>I'm in the center of the flex container!</h1>
  </div>
  <div class=”side”>
    <h1>I'm on the other side of the flex container!</h1>
  </div>
</div>
.container {
  display: flex;
}

.side {
  width: 100px;
  flex-grow: 1;
}

.center {
  width: 100px;
  flex-grow: 2;
}
In the example above, the .container div has a display value of flex, so its three child divs will be positioned next to each other. If there is additional space in the .container div (in this case, if it is wider than 300 pixels), the flex items will grow to fill it. The .center div will stretch twice as much as the .side divs. For example, if there were 60 additional pixels of space, the center div would absorb 30 pixels and the side divs would absorb 15 pixels each.

If a max-width is set for an element, it will not grow larger than that even if there is more space for it to absorb.

All of the previous properties we have learned are declared on flex containers, or the parent elements. This property — flex-grow — is the first we have learned that is declared on flex items.
 -->
Instructions
1.
Assign .top.side and .top.center a flex-grow value of 1. Stretch and shrink the browser.

2.
Assign .middle.center the flex-grow value of 1. Stretch and shrink the browser again.

3.
Assign .bottom.side a flex-grow value of 1 and .bottom.center a flex-grow value of 2. Shrink and stretch the browser again. Compare the differences in behavior of all three sections.

+++++++++++++++++++++++++++++++++++
FLEXBOX
flex-shrink

<!-- Just as the flex-grow property proportionally stretches flex items, the flex-shrink property can be used to specify which elements will shrink and in what proportions.

You may have noticed in earlier exercises that flex items shrank when the flex container was too small, even though we had not declared the property. This is because the default value of flex-shrink is 1. However, flex items do not grow unless the flex-grow property is declared because the default value of flex-grow is 0.

<div class="container">
  <div class="side">
    <h1>I'm on the side of the flex container!</h1>
  </div>
  <div class="center">
    <h1>I'm in the center of the flex container!</h1>
  </div>
  <div class="side">
    <h1>I'm on the other side of the flex container!</h1>
  </div>
</div>
.container {
  display: flex;
}

.side {
  width: 100px;
  flex-shrink: 1;
}

.center {
  width: 100px;
  flex-shrink: 2;
}
In the example above, the .center div will shrink twice as much as the .side divs if the .container div is too small to fit the elements within it. If the content is 60 pixels too large for the flex container that surrounds it, the .center div will shrink by 30 pixels and the outer divs will shrink by 15 pixels each. Margins are unaffected by flex-grow and flex-shrink.

Keep in mind, minimum and maximum widths will take precedence over flex-grow and flex-shrink. As with flex-grow, flex-shrink will only be employed if the parent container is too small or the browser is adjusted. -->

Instructions
1.
Assign .top.side a flex-shrink value of 2.

Stretch and shrink the browser. Because the default value for flex-shrink is 1, the .top.center div will shrink but not as much as the .side divs.

2.
Assign .middle.side a flex-shrink value of 0.

Stretch and shrink the browser. How do the .middle divs resize differently than the .top divs?

3.
Assign the .bottom.center div a flex-shrink value of 2.

Shrink and stretch the browser again. How do the .bottom divs resize differently than the .top and .middle divs?

++++++++++++++++++++++++++++++++++

FLEXBOX
flex-basis

<!-- In the previous two exercises, the dimensions of the divs were determined by heights and widths set with CSS. Another way of specifying the width of a flex item is with the flex-basis property. flex-basis allows us to specify the width of an item before it stretches or shrinks.

<div class="container">
  <div class=”side”>
    <h1>Left side!</h1>
  </div>
  <div class="center">
    <h1>Center!</h1>
  </div>
  <div class="side">
    <h1>Right side!</h1>
  </div>
</div>
.container {
  display: flex;
}

.side {
  flex-grow: 1;
  flex-basis: 100px;
}

.center {
  flex-grow: 2;
  flex-basis: 150px;
}
In the example above, the .side divs will be 100 pixels wide and the .center div will be 150 pixels wide if the .container div has just the right amount of space (350 pixels, plus a little extra for margins and borders). If the .container div is larger, the .center div will absorb twice as much space as the .side divs.

The same would hold true if we assigned flex-shrink values to the divs above as well.
 -->
Instructions
1.
In the .grow.side rule in style.css, add a flex-basis of 60px.

2.
In the same rule, add a flex-grow value of 1.

3.
In the .grow.center rule in style.css, add a flex-grow value of 3.

4.
In the .shrink.side rule in style.css, add a flex-basis value of 300px.

5.
In the same rule, add a flex-shrink value of 3.

6.
In the .shrink.center rule in style.css, add a flex-shrink value of 2.

7.
In the same rule, add a flex-basis of 150px. Now stretch and shrink the browser.

++++++++++++++++++++++++++++++++++
FLEXBOX
flex

<!-- The flex property provides a convenient way for specifying how elements stretch and shrink, while simplifying the CSS required. The flex property allows you to declare flex-grow, flex-shrink, and flex-basis all in one line.

Note: The flex property is different from the flex value used for the display property.

.big {
  flex-grow: 2;
  flex-shrink: 1;
  flex-basis: 150px;
}

.small {
  flex-grow: 1;
  flex-shrink: 2;
  flex-basis: 100px;
}
In the example above, all elements with class big will grow twice as much as elements with class small. Keep in mind, this doesn’t mean big items will be twice as big as small items, they’ll just take up more of the extra space.

The CSS below declares these three properties in one line.

.big {
  flex: 2 1 150px;
}

.small {
  flex: 1 2 100px;
}
In the example above, we use the flex property to declare the values for flex-grow, flex-shrink, and flex-basis (in that order) all in one line.

.big {
 flex: 2 1;
}
In the example above, we use the flex property to declare flex-grow and flex-shrink, but not flex-basis.

.small {
  flex: 1 20px;
}
In the example above, we use the flex property to declare flex-grow and flex-basis. Note that there is no way to set only flex-shrink and flex-basis using 2 values.

The browser to the right has two flex containers, each with three flex items. In style.css, examine the values for each of these items. Notice that the flex-grow and flex-basis values are set for the grey divs. Stretch the browser window to increase its width. Observe that once these divs reach 100 pixels wide, the center div begins to grow faster than the outer divs. Shrink the browser window and notice that something important happens: once the divs reach 100 pixels wide, they begin to shrink equally. This is because flex-shrink defaults to 1, whereas flex-grow defaults to 0.
 -->
1.
In #top .side, all three values for flex-grow, flex-shrink, and flex-basis are assigned individually. Refactor them to be declared in one line.

2.
In #top .center, all three values for flex-grow, flex-shrink, and flex-basis are assigned individually. Refactor them to be declared in one line.

3.
In #bottom .side, all three values for flex-grow, flex-shrink, and flex-basis are assigned individually. Refactor them to be declared in one line.

4.
In #bottom .center, all three values for flex-grow, flex-shrink, and flex-basis are assigned individually. Refactor them to be declared in one line.

++++++++++++++++++++++++++++++++++++++++
FLEXBOX
flex-wrap

<!-- Sometimes, we don’t want our content to shrink to fit its container. Instead, we might want flex items to move to the next line when necessary. This can be declared with the flex-wrap property. The flex-wrap property can accept three values:

wrap — child elements of a flex container that don't fit into a row will move down to the next line
wrap-reverse — the same functionality as wrap, but the order of rows within a flex container is reversed (for example, in a 2-row flexbox, the first row from a wrap container will become the second in wrap-reverse and the second row from the wrap container will become the first in wrap-reverse)
nowrap — prevents items from wrapping; this is the default value and is only necessary to override a wrap value set by a different CSS rule.
<div class="container">
  <div class="item">
    <h1>We're going to wrap!</h1>
  </div>
  <div class="item">
    <h1>We're going to wrap!</h1>
  </div>
  <div class="item">
    <h1>We're going to wrap!</h1>
  </div>
</div>
.container {
  display: inline-flex;
  flex-wrap: wrap;
  width: 250px;
}

.item {
  width: 100px;
  height: 100px;
}
In the example above, three flex items are contained by a parent flex container. The flex container is only 250 pixels wide so the three 100 pixel wide flex items cannot fit inline. The flex-wrap: wrap; setting causes the third, overflowing item to appear on a new line, below the other two item.

Note: The flex-wrap property is declared on flex containers.
 -->
Instructions
1.
Add a flex-wrap property with the value of wrap to the div with the id #wrap. Shrink and stretch the browser.

2.
Add a flex-wrap property with the value of nowrap to the div with the id #nowrap. Shrink and stretch the browser.

3.
Add a flex-wrap property with the value of wrap-reverse to the div with the id #reverse. Shrink and stretch the browser.

4.
Add a justify-content value of space-around to the .container rule in style.css. Stretch and shrink the browser. What's different this time?

+++++++++++++++++++++++++++++++++++
FLEXBOX
Align-content

<!-- Now that elements can wrap to the next line, we might have multiple rows of flex items within the same container. In a previous exercise, we used the align-items property to space flex items from the top to the bottom of a flex container. align-items is for aligning elements within a single row. If a flex container has multiple rows of content, we can use align-content to space the rows from top to bottom.

align-content accepts six values:

flex-start — all rows of elements will be positioned at the top of the parent container with no extra space between.
flex-end — all rows of elements will be positioned at the bottom of the parent container with no extra space between.
center — all rows of elements will be positioned at the center of the parent element with no extra space between.
space-between — all rows of elements will be spaced evenly from the top to the bottom of the container with no space above the first or below the last.
space-around — all rows of elements will be spaced evenly from the top to the bottom of the container with the same amount of space at the top and bottom and between each element.
stretch — if a minimum height or no height is specified, the rows of elements will stretch to fill the parent container from top to bottom (default value).
<div class="container">
  <div class=”child”>
    <h1>1</h1>
  </div>
  <div class="child">
    <h1>2</h1>
  </div>
  <div class="child">
    <h1>3</h1>
  </div>
  <div class="child">
    <h1>4</h1>
  </div>
</div>
.container {
  display: flex;
  width: 400px;
  height: 400px;
  flex-wrap: wrap;
  align-content: space-around;
}

.child {
  width: 150px;
  height: 150px;
}
In the example above, there are four flex items inside of a flex container. The flex items are set to be 150 pixels wide each, but the parent container is only 400 pixels wide. This means that no more than two elements can be displayed inline. The other two elements will wrap to the next line and there will be two rows of divs inside of the flex container. The align-content property is set to the value of space-around, which means the two rows of divs will be evenly spaced from top to bottom of the parent container with equal space before the first row and after the second, with double space between the rows.

Below, we will see each of the properties in action!

Note: The align-content property is declared on flex containers.
 -->
Instructions
1.
Set the align-content property of #flexstart to flex-start.

2.
Set the align-content property of #flexend to flex-end.

3.
Set the align-content property of #center to center.

4.
Set the align-content property of #between to space-between.

5.
Set the align-content property of #around to space-around.

6.
Change the height declaration in the .left, .right, .center CSS rule to say min-height instead. What happens to the flex items in the #stretch container?

+++++++++++++++++++++++++++++++++++++++++

FLEXBOX
flex-direction

<!-- Up to this point, we’ve only covered flex items that stretch and shrink horizontally and wrap vertically. As previously stated, flex containers have two axes: a major axis and a cross axis. By default, the major axis is horizontal and the cross axis is vertical.

The major axis is used to position flex items with the following properties:

justify-content
flex-wrap
flex-grow
flex-shrink
The cross axis is used to position flex items with the following properties:

align-items
align-content
The major axis and cross axis are interchangeable. We can switch them using the flex-direction property. If we add the flex-direction property and give it a value of column, the flex items will be ordered vertically, not horizontally.

<div class="container">
  <div class="item">
    <h1>1</h1>
  </div>
  <div class="item">
    <h1>2</h1>
  </div>
  <div class="item">
    <h1>3</h1>
  </div>
  <div class="item">
    <h1>4</h1>
  </div>
  <div class="item">
    <h1>5</h1>
  </div>
</div>
.container {
  display: flex;
  flex-direction: column;
  width: 1000px;
}
.item {
  height: 100px;
  width: 100px;
}
In the example above, the five divs will be positioned in a vertical column. All of these divs could fit in one horizontal row. However, the column value tells the browser to stack the divs one on top of the other. As explained above, properties like justify-content will not behave the way they did in previous examples.

The flex-direction property can accept four values:

row — elements will be positioned from left to right across the parent element starting from the top left corner (default).
row-reverse — elements will be positioned from right to left across the parent element starting from the top right corner.
column — elements will be positioned from top to bottom of the parent element starting from the top left corner.
column-reverse — elements will be positioned from the bottom to the top of the parent element starting from the bottom left corner.
Below, we’ll investigate how these work.

Note: The flex-direction property is declared on flex containers.
 -->
Instructions
1.
Give the div with id #row a flex-direction of row.

2.
Give the div with id #row-reverse a flex-direction of row-reverse.

3.
Give the div with id #column a flex-direction of column.

4.
Give the div with id #column-reverse a flex-direction of column-reverse.

5.
Change the height property of .container elements to be max-height. Remember to stretch and shrink the browser after each checkpoint so you can see the effects.

6.
Set the align-items value of the .container div to center.

7.
Set the justify-content value of the .container div to space-around.

8.
Set the flex-grow property of .box divs to 1. In which direction do the elements grow?

+++++++++++++++++++++++++++++++++
FLEXBOX
flex-flow

<!-- Like the flex property, the flex-flow property is used to declare both the flex-wrap and flex-direction properties in one line.

.container {
  display: flex;
  flex-wrap: wrap;
  flex-direction: column;
}
In the example above, we take two lines to accomplish what can be done with one.

.container {
  display: flex;
  flex-flow: column wrap;
}
In the example above, the first value in the flex-flow declaration is a flex-direction value and the second is a flex-wrap value. All values for flex-direction and flex-wrap are accepted.

Note: The flex-flow property is declared on flex containers.
 -->
Instructions
1.
In the #row-reverse selector, set the flex-flow property to have a direction of row-reverse and to wrap elements. You should be able to accomplish this in one line.

2.
In the #column selector, set the flex-flow property to give elements a direction of column and to wrap elements. You should be able to accomplish this in one line.

+++++++++++++++++++++++++++++++++++++++++
FLEXBOX
Nested Flexboxes

<!-- So far, we’ve had multiple flex containers on the same page to explore flex item positioning. It is also possible to position flex containers inside of one another.

<div class="container">
  <div class="left">
    <img class="small" src="#"/>
    <img class="small" src="#"/>
    <img class="small" src="#" />
  </div>
  <div class="right">
    <img class="big" src="#" />
  </div>
</div>
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}

.left {
  display: inline-flex;
  flex: 2 1 200px;
  flex-direction: column;
}

.right {
  display: inline-flex;
  flex: 1 2 400px;
  align-items: center;
}

.small {
  height: 200px;
  width: auto;
}

.large {
  height: 600px; 
  width: auto;
}
In the example above, a div with three smaller images will display from top to bottom on the left of the page (.left). There is also a div with one large image that will display on the right side of the page (.right). The left div has a smaller flex-basis but stretches to fill more extra space; the right div has a larger flex-basis but stretches to fill less extra space. Both divs are flex items and flex containers. The items have properties that dictate how they will be positioned in the parent container and how their flex item children will be positioned in them.

We’ll use the same formatting above to layout the simple page to the right.
 -->
Instructions
1.
Set the display property of .main to flex.

2.
Set the align-items property of .main to center.

3.
Set the justify-content property of .main to space-around.

4.
Set the display property of .container to flex.

5.
Set the flex-direction property of .container to column.

6.
Set the justify-content property of .container to center.

7.
Set the align-items property of .container to center.

8.
Repeat steps 4, 6, and 7 for .child.

-----------------------------------------------------------
07/01/29/12/2018

CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
canIVote()

const canIVote = age => {
    if (age >= 18) {
        return true
    } else {
        return false
    }
}
/*
// Alternate solutions:

// As a function declaration:
function canIVote(age) {
    if (age >= 18) {
        return true
    } else {
        return false
    }
}

// Using a ternary:
const canIVote = (age) => age >= 18 ? true : false
*/

console.log(canIVote(19))

+++++++++++++++++++++++++++++

CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
agreeOrDisagree()

const agreeOrDisagree = (first, second) => {
    if (first === second) {
        return 'You agree!'
    } else {
        return 'You disagree!'
    }
}
/*
// As a function declaration:
function agreeOrDisagree(first, second) {
   if (first === second) {
        return 'You agree!'
    } else {
        return 'You disagree!'
    }
}

// As a ternary: 
const agreeOrDisagree = (first, second) => (first === second) ? 'You agree!' : 'You disagree!'
*/

console.log(agreeOrDisagree("yep", "yep")) 

+++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
lifePhase()

const lifePhase = age => {
    if (age < 0 || age > 140) {
        return 'This is not a valid age'
    } else if (age < 4) {
        return 'baby'
    } else if (age < 13) {
        return 'child'
    } else if (age < 20) {
        return 'teen'
    } else if (age < 65) {
        return 'adult'
    } else {
        return 'senior citizen'
    }
}
/*
// As a function declaration:
function lifePhase (age) {
    if (age < 0 || age > 140) {
       return 'This is not a valid age'
   } else if (age < 4) {
        return 'baby'
    } else if (age < 13) {
        return 'child'
    } else if (age < 20) {
       return 'teen'
    } else if (age < 65) {
       return 'adult'
    } else {
        return 'senior citizen'
    }  
}
*/
console.log(lifePhase(5)) 

++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
finalGrade()

const finalGrade = (midterm, final, homework) => {
    if ((midterm < 0 || midterm > 100) || (final < 0 || final > 100) || (homework < 0 || homework > 100)) {
        return 'You have entered an invalid grade.'
    }
    let average = (midterm + final + homework) / 3
    if (average < 60) {
        return 'F'
    }
    else if (average < 70) {
        return 'D'
    }
    else if (average < 80) {
        return 'C'
    }
    else if (average < 90) {
        return 'B'
    } else {
        return 'A'
    }
}

/*
//as a function declaration:
function finalGrade(midterm, final, homework) {
    if ((midterm < 0 || midterm > 100) || (final < 0 || final > 100) || (homework < 0 || homework > 100)) {
        return 'You have entered an invalid grade.'
    }
    let average = (midterm + final + homework) / 3
    if (average < 60) {
        return 'F'
    }
    else if (average < 70) {
        return 'D'
    }
    else if (average < 80) {
        return 'C'
    }
    else if (average < 90) {
        return 'B'
    } else {
        return 'A'
    }
}
*/

+++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
reportingForDuty()

const reportingForDuty = (rank, lastName) => `${rank} ${lastName} reporting for duty!`

/*
// Using string concatenation:
const reportingForDuty = (rank, lastName) => rank + " " + lastName + " " + "reporting for duty!"

// As a function declaration:
function reportingForDuty(rank, lastName) {
    return `${rank} ${lastName} reporting for duty!`
}
*/

++++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
Fix The Broken Code

const rollTheDice = () => {
  // Math.random() gives us a random number from 0 up to, but not including, 1
  // We multiplied that by 6 to get a number between 0 and up to, but not including, 6
  // But since we actually wanted numbers from 1 to 6, inclusive, we added 1
    let die1 = Math.random() * 6 + 1
    let die2 = Math.random() * 6 + 1
    return die1 + die2
}

======>>>>>fixed
const rollTheDice = () => {
    let die1 = Math.floor(Math.random() * 6 + 1)
    let die2 = Math.floor(Math.random() * 6 + 1)
    return die1 + die2
} 

+++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
calculateWeight()

const calculateWeight = (earthWeight, planet) => {
    switch (planet) {
        case 'Mercury':
            return earthWeight * .378;
        case 'Venus':
            return earthWeight * .907;
        case 'Mars':
            return earthWeight * .377;
        case 'Jupiter':
            return earthWeight * 2.36;
        case 'Saturn':
            return earthWeight * .916;
        default:
            return 'Invalid Planet Entry. Try: Mercury, Venus, Mars, Jupiter, or Saturn.'
    }
}
/*
// As a function declaration: 
function calculateWeight(earthWeight, planet) {
    switch (planet) {
        case 'Mercury':
            return earthWeight * .378;
        case 'Venus':
            return earthWeight * .907;
        case 'Mars':
            return earthWeight * .377;
        case 'Jupiter':
            return earthWeight * 2.36;
        case 'Saturn':
            return earthWeight * .916;
	 default:
		return 'Invalid Planet Entry. Try: Mercury, Venus, Mars, Jupiter, or Saturn.'
    }
}
*/
console.log(calculateWeight(100, 'Jupiter'))

+++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
truthyOrFalsy()

const truthyOrFalsy = value => {
    if (value) {
        return true
    }
    return false
}

/*
// As a function declaration:
function truthyOrFalsy(value) {
    if (value) {
        return true
    } else {
        return false
    }
}

// Using a ternary: 
const truthyOrFalsy = value => value ? true : false 
*/
console.log(truthyOrFalsy(0))


++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
numImaginaryFriends()

const numImaginaryFriends = totalFriends => Math.round(totalFriends * .33)

/*
// As a function declaration:
    function numImaginaryFriends(totalFriends) {
    return Math.round(totalFriends * .33)
}
*/
console.log(numImaginaryFriends(18))

+++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
sillySentence()

const sillySentence = (adjective, verb, noun) => `I am so ${adjective} because I ${verb} coding! Time to write some more awesome ${noun}!`

/*
// With string concatenation:
const sillySentence = (adjective, verb, noun) => 'I am so ' + adjective + ' because I ' + verb +  ' coding! Time to write some more awesome ' + noun + '!'


// As a function declaration:
function sillySentence(adjective, verb, noun) {
    return `I am so ${adjective} because I ${verb} coding! Time to write some more awesome ${noun}!`
}
*/

console.log(sillySentence('excited', 'love', 'functions')) 

++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
howOld()

/* 
Our solution is written as a function expression and uses string interpolation, but it would be equally acceptable to use a function declaration and/or string concatenation
*/

const howOld = (age, year) => {
// The following two lines make it so that our function always knows the current year.
    let dateToday = new Date();
    let thisYear = dateToday.getFullYear();
// It is totally ok if your function used the current year directly!
  
    const yearDifference = year - thisYear
    const newAge = age + yearDifference
    if (newAge < 0) {
        return `The year ${year} was ${-newAge} years before you were born`
    } else if (newAge > age) {
        return `You will be ${newAge} in the year ${year}`
    } else {
        return `You were ${newAge} in the year ${year}`
    }
}

console.log(howOld(28, 1990))

++++++++++++++++++++++++++++++++++

CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
Fix the broken code (round 2)!


const whatRelation = percentSharedDNA => {
    if (percentSharedDNA === 100) {
        return 'You are likely identical twins.'
    }
    if (percentSharedDNA > 34) {
        return 'You are likely parent and child or full siblings.'
    }
    if (percentSharedDNA < 13) {
        return 'You are likely grandparent and grandchild, aunt/uncle and niece/nephew, or half siblings.'
    }
    if (percentSharedDNA > 5) {
        return 'You are likely 1st cousins.'
    }
    if (percentSharedDNA > 2) {
        return 'You are likely 2nd cousins.'
    }
    if (percentSharedDNA > 0) {
        return 'You are likely 3rd cousins'
    }
    return 'You are likely not related.'
}

console.log(whatRelation(34))
// Should print 'You are likely grandparent and grandchild, aunt/uncle and niece/nephew, or half siblings.'

console.log(whatRelation(3))
// Should print 'You are likely 2nd cousins.'


===============>>>>>>>>>>>>
const whatRelation = percentSharedDNA => {
    if (percentSharedDNA === 100) {
        return 'You are likely identical twins.'
    }
    if (percentSharedDNA > 34) {
        return 'You are likely parent and child or full siblings.'
    }
    if (percentSharedDNA > 13) {
        return 'You are likely grandparent and grandchild, aunt/uncle and niece/nephew, or half siblings.'
    }
    if (percentSharedDNA > 5) {
        return 'You are likely 1st cousins.'
    }
    if (percentSharedDNA > 2) {
        return 'You are likely 2nd cousins.'
    }
    if (npercentSharedDNA > 0) {
        return 'You are likely 3rd cousins'
    }
    return 'You are likely not related.'
}

console.log(whatRelation(34))

console.log(whatRelation(3))

++++++++++++++++++++++++++++++++++++++++++++

CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
tipCalculator()

const tipCalculator = (quality, total) => {
    switch (quality) {
        case 'bad':
            return total * .05;
        case 'ok':
            return total * .15;
        case 'good':
            return total * .20;
        case 'excellent':
            return total * .30;
        default:
            return total * .18;

    }
}
/*
// As a function declaration:
function tipCalculator(quality, total) {
    switch (quality) {
        case 'bad':
            return total * .05;
        case 'ok':
            return total * .15;
        case 'good':
            return total * .20;
        case 'excellent':
            return total * .30;
        default:
            return total * .18;

    }
}
*/
console.log(tipCalculator('good', 100))

++++++++++++++++++++++++++++++++
CODE CHALLENGES: JAVASCRIPT FUNDAMENTALS
toEmoticon()

const toEmoticon = meaning => {
    switch (meaning) {
        case 'shrug':
            return '|_{"}_|'
        case 'smiley face':
            return ':)';
        case 'frowny face':
            return ':(';
        case 'winky face':
            return ';)';
        case 'heart':
            return '<3';
        default:
            return '|_(* ~ *)_|';
    }
}
/*
// As a function declaration: 
function toEmoticon(meaning) {
    switch (meaning) {
        case 'shrug':
            return '|_{"}_|'
        case 'smiley face':
            return ':)';
        case 'frowny face':
            return ':(';
        case 'winky face':
            return ';)';
        case 'heart':
            return '<3';
        default:
            return '|_(* ~ *)_|';
    }
}
*/
console.log(toEmoticon("whatever"))

---------------------------------------------------------------

08/01/2019

CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
reverseArray()
###Array.reverse()

const reverseArray = arr => {
    let reversed = [];
    for (let i = arr.length - 1; i >= 0; i--) {
        reversed.push(arr[i]);
    }
    return reversed
}
/*
// Alternate solutions:

// Using the .unshift() method
const reverseArray = arr => {
    let reversed = [];
    for (let i = 0; i < arr.length; i++) {
        reversed.unshift(arr[i]);
    }
    return reversed
}

// As a function declaration:
function reverseArray(arr) {
    let reversed = [];
    for (let i = arr.length - 1; i >= 0; i--) {
        reversed.push(arr[i]);
    }
    return reversed
}
*/

const sentence = ['sense.','make', 'all', 'will', 'This'];

console.log(reverseArray(sentence)); 


++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
greetAliens()

###.forEach()

const greetAliens = arr => {
      for (let i = 0; i < arr.length; i++) {
            console.log('Oh powerful ' + arr[i] + ', we humans offer our unconditional surrender!');
      }
}

/*
// Alternate solutions:

// Using string interpolation
const greetAliens = arr
for (let i = 0; i<arr.length; i++){
    console.log(`Oh powerful ${arr[i]}, we humans offer our unconditional surrender!`);
}

// As a function declaration:
function greetAliens(arr) {
for (let i = 0; i<arr.length; i++){
    console.log(`Oh powerful ${arr[i]}, we humans offer our unconditional surrender!`);
}
}

*/

const aliens = ["Blorgous", "Glamyx", "Wegord", "SpaceKing"];

greetAliens(aliens)

+++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
convertToBaby()
###map

const convertToBaby = arr => {
      const babyArray = [];
      for (let i = 0; i < arr.length; i++) {
            babyArray.push('baby ' + arr[i]);
      }
      return babyArray
}

/*
// As a function declaration:
function convertToBaby(arr) {
      const babyArray = [];
      for (let i = 0; i < arr.length; i++) {
            babyArray.push('baby ' + arr[i]);
      }
      return babyArray
}
*/ 

const animals = ['panda', 'turtle', 'giraffe', 'hippo', 'sloth', 'human'];

console.log(convertToBaby(animals)) 

++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
Fix The Broken Code!

const numbers = [5, 3, 9, 30];

const smallestPowerOfTwo = arr => {
      let results = [];
      // The 'outer' for loop - loops through each element in the array
      for (let i = 0; i < arr.length; i++) {
            number = arr[i];

            // The 'inner' while loop - searches for smallest power of 2 greater than the given number
            i = 1;
            while (i < number) {
                  i = i * 2;
            }
            results.push(i);
      }
      return results
}

console.log(smallestPowerOfTwo(numbers)) 
// Should print the returned array [ 8, 4, 16, 32 ] instead prints the returned array [8]

=============>>>>>>>>>>>>>>

const numbers = [5, 3, 9, 30];

const smallestPowerOfTwo = arr => {
      let results = [];
      // The 'outer' for loop:
      for (let i = 0; i < arr.length; i++) {
            number = arr[i];

            // The 'inner' while loop:
            // We needed to create a new variable!
            let j = 1;
            while (j < number) {
                  j = j * 2;
            }
            results.push(j);
      }
      return results
}

console.log(smallestPowerOfTwo(numbers)) 

++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
declineEverything() and acceptEverything()
###forEach

const veggies = ['broccoli', 'spinach', 'cauliflower', 'broccoflower'];

const politelyDecline = (veg) => {
      console.log('No ' + veg + ' please. I will have pizza with extra cheese.');
}

// Checkpoint 1 solutions:
const declineEverything = arr => {
  arr.forEach(politelyDecline)
}

/*
// As a function declaration:
function declineEverything(arr) {
      arr.forEach(politelyDecline)
}
*/


// Checkpoint 2 solutions:
// Using an anonymous function and string interpolation:
const acceptEverything = arr => {
  arr.forEach(e => {
    console.log(`Ok, I guess I will eat some ${e}.`)
  })
}

/*
// Using a named function and string concatenation:
const grudginglyAccept = veg => {
      console.log('Ok, I guess I will eat some ' + veg + '.');
}
const acceptEverything = arr => {
      arr.forEach(grudginglyAccept)
}

// Using a loop:
const acceptEverything = arr => {
 for(let i = 0; i<arr.length; i++){
    console.log(`Ok, I guess I will eat some ${arr[i]}.`)
 }
}
*/

++++++++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
squareNums()
###map

const numbers = [2, 7, 9, 171, 52, 33, 14];

const toSquare = num => num * num

const squareNums = arr => arr.map(toSquare) 

/*
// Using an anonymous function:
const squareNums = arr => arr.map(e => e * e)

// As a function declaration plus using our named function:
function squareNums(arr) {
    return arr.map(toSquare)
}
*/

console.log(squareNums(numbers))

+++++++++++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
shoutGreetings()
###map

const shoutGreetings = arr => arr.map(word => word.toUpperCase() + '!');

/*
// As a function declaration AND using a loop:
function shoutGreetings(arr) {
    let shoutArray = []
    for(let i = 0; i<arr.length; i++){
        shoutArray.push(arr[i].toUpperCase() + '!')
    }
    return shoutArray
}
*/
const greetings = ['hello', 'hi', 'heya', 'oi', 'hey', 'yo']

console.log(shoutGreetings(greetings))

++++++++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
sortYears()

const sortYears = arr => arr.sort((x, y) => y - x);

/*
// As a function declaration AND using a named function:
function sortYears(arr) {
      const checkYears = (year1, year2) => year2 - year1
      return arr.sort(checkYears)
}
*/

const years = [1970, 1999, 1951, 1982, 1963, 2011, 2018, 1922]

console.log(sortYears(years))

++++++++++++++++++++++++++++++++++++++

CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
justCoolStuff()

const justCoolStuff = (firstArray, secondArray) => firstArray.filter(item => secondArray.includes(item))

/*
// As a function declaration AND using named function w/ a loop:
function justCoolStuff(firstArray, secondArray) {
      function isInSecondArray(item){
            for(let i = 0; i<secondArray.length; i++){
                  if (secondArray[i] === item){
                        return true
                  }
            }
            return false 
      }
      return firstArray.filter(isInSecondArray)
}
*/

const coolStuff = ['gameboys', 'skateboards', 'backwards hats', 'fruit-by-the-foot', 'pogs', 'my room', 'temporary tattoos'];

const myStuff = [ 'rules', 'fruit-by-the-foot', 'wedgies', 'sweaters', 'skateboards', 'family-night', 'my room', 'braces', 'the information superhighway']; 

console.log(justCoolStuff(myStuff, coolStuff))

+++++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
isTheDinnerVegan()

const isTheDinnerVegan = arr => arr.every(food => food.source === 'plant');

/*
// Alternate solution:
// Using a function declaration, loop, and helper function:
function isTheDinnerVegan(arr) {
      const isVegan = (food) => {
            if (food.source === 'plant') {
                  return true;
            }
            return false;
      }
      for(let i = 0; i<arr.length; i++){
            if (!isVegan(arr[i])){
                  return false 
            }
      }
      return true
}
*/

const dinner = [{name: 'hamburger', source: 'meat'}, {name: 'cheese', source: 'dairy'}, {name: 'ketchup', source:'plant'}, {name: 'bun', source: 'plant'}, {name: 'dessert twinkies', source:'unknown'}];

console.log(isTheDinnerVegan(dinner))

+++++++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
sortSpeciesByTeeth()

const speciesArray = [ {speciesName:'shark', numTeeth:50}, {speciesName:'dog', numTeeth:42}, {speciesName:'alligator', numTeeth:80}, {speciesName:'human', numTeeth:32}];

const sortSpeciesByTeeth = arr => arr.sort((speciesObj1, speciesObj2) => speciesObj1.numTeeth > speciesObj2.numTeeth)

/*
// As a function declaration AND using a named function:
function sortSpeciesByTeeth(arr) {
      const compareTeeth = (speciesObj1, speciesObj2) => speciesObj1.numTeeth > speciesObj2.numTeeth
      return arr.sort(compareTeeth)
}
*/

console.log(sortSpeciesByTeeth(speciesArray))

+++++++++++++++++++++++++++++++++++++++++++++

CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
findMyKeys()

const findMyKeys = arr => arr.findIndex(item => item === 'keys')

/*
// Alternate solution:
// As a function declaration using a loop:
function findMyKeys(arr) {
      let index = -1;
      for (let i = 0; i < arr.length; i++) {
            if (arr[i] === 'keys') {
                  index = i
                  break
            }
      }
      return index
}
*/
const randomStuff = ['credit card', 'screwdriver', 'receipt', 'gum', 'keys', 'used gum', 'plastic spoon'];

console.log(findMyKeys(randomStuff))

++++++++++++++++++++++++++++++++++++++
CODE CHALLENGES: INTERMEDIATE JAVASCRIPT
dogFactory()

// Final solution:
const dogFactory = (name, breed, weight) => {
    return {
        _name: name,
        _breed: breed,
        _weight: weight,
        get name() {
            return this._name;
        },
        set name(newName) {
            this._name = newName;
        },
        get breed() {
            return this._breed;
        },
        set breed(newBreed) {
            this._breed = newBreed;
        },
        get weight() {
            return this._weight;
        },
        set weight(newWeight) {
            this._weight = newWeight;
        },
        bark() {
            return 'ruff! ruff!'
        },
        eatTooManyTreats() {
            this._weight++
        }
    }
}

/*
// Solution to checkpoint 1:
const dogFactory = (name, breed, weight) => {
      return {
            name: name,
            breed: breed,
            weight: weight
      }
}

// Solution to checkpoint 2:
const dogFactory = (name, breed, weight) => {
      return {
            _name: name,
            _breed: breed,
            _weight: weight,
            get name() {
                  return this._name;
            },
            set name(newName) {
                  this._name = newName;
            },
            get breed() {
                  return this._breed;
            },
            set breed(newBreed) {
                  this._breed = newBreed;
            },
            get weight() {
                  return this._weight;
            },
            set weight(newWeight) {
                  this._weight = newWeight;
            }
      }
}

*/

console.log(dogFactory('Joe', 'Pug', 27))

---------------------------------------------------------------------
08/01/2019

DEBUGGING JAVASCRIPT CODE
Reading Error Stack Traces

Now that we know what information we can get from an error stack trace, let's take a look at an example.

/home/ccuser/workspace/learn-javascript-debugging-code/app.js:1
myVariable;
^

ReferenceError: myVariable is not defined
...
Using this stack trace, let's answer three questions you should ask yourself every time you want to debug an error:

In what line did the error occur? You can almost always find this information on the first line of the stack trace in the following format <file path>/<file name>:<line number>. In this example, the location is app.js:1. This means that the error was thrown in the file named app.js on line 1.
What type of error was thrown? The first word on the fifth line of the stack trace is the type of error that was thrown. In this case, the type of error was ReferenceError. We will discuss this error type in the next exercise.
What is the error message? The rest of the fifth line after the error type provides an error message, describing what went wrong. In this case, the description is myVariable is not defined.
You might notice in this example we skipped explaining a few lines in the stack trace and only included the beginning of the stack trace. A large part of debugging errors is recognizing which pieces of information are useful and which ones aren't. For now, you will succeed by focusing on just the first and fifth lines of your error stack traces.

+++++++++++++++++++++++++++++++++++++
DEBUGGING JAVASCRIPT CODE
JavaScript Error Types

Now that you can identify the type of error from an error stack trace, you might be wondering what the different types of errors mean.

Here are three common error types:

SyntaxError: This error will be thrown when a typo creates invalid code — code that cannot be interpreted by the compiler. When this error is thrown, scan your code to make sure you properly opened and closed all brackets, braces, and parentheses and that you didn't include any invalid semicolons.
ReferenceError: This error will be thrown if you try to use a variable that does not exist. When this error is thrown, make sure all variables are properly declared.
TypeError: This error will be thrown if you attempt to perform an operation on a value of the wrong type. For example, if we tried to use a string method on a number, it would throw a TypeError.
There are seven types of built-in JavaScript errors in total. You can find more information about all of them at the MDN JavaScript Error documentation. Whenever you are confronted with an error you can't comprehend, consulting this documentation is a great place to start.

myVariable++;
// 1 - What type of error will be thrown on the line above: 
ReferenceError
const myString = 42;
myString.substring(0);
// 2 - What type of error will be thrown on the line above: 
TypeError
const myRandomNumber; = Math.random();
// 3 - What type of error will be thrown on the line above: 
SyntaxError

+++++++++++++++++++++++++++++++++++++++

DEBUGGING JAVASCRIPT CODE
Debugging Errors

Here's a process for efficiently working through your code's errors one by one:

Run your code. Using the first error's stack trace, identify the error's type, description, and location.
Go to the file name and line number indicated by the error stack trace. Using the error type and description, identify the bug in your code.
Fix the bug and re-run your code.
Repeat steps 1-3 until your code no longer throws any errors.
While these steps may seem simple, it can be easy to get overwhelmed by errors in practice. Using these steps, you can tackle your errors one at a time and soon will have your code running error-free.

+++++++++++++++++++++++++++++++++++++
DEBUGGING JAVASCRIPT CODE
Locating Silent Bugs

Errors thrown by the computer are really useful because they identify the bug type and location for you right away. However, even if your code runs error-free, it is not necessarily bug-free.

You may find that your code is consistently returning incorrect values without throwing any errors. A lack of thrown errors does not mean your code logic is completely correct.

An incredibly powerful tool for locating bugs is a method you likely learned very early on in your JavaScript journey: console.log()!

By adding print statements to our code, we can identify where things have gone wrong.

Let's try using console.log() to do some debugging.

++++++++++++++++++++++++++++++++++
DEBUGGING JAVASCRIPT CODE
Debugging with console.log()

Let's synthesize our workflow from the previous exercise into a reusable set of debugging steps.

Go to the beginning of the malfunctioning code. Print out all starting variables, existing values, and arguments using console.log(). If the values are what you expect, move on to the next piece of logic in the code. If not, you have identified a bug and should skip to step 3.
After the next piece of logic in your code, add console.log() statements to ensure updated variables have the values that you now expect and that the block of code is being executed. If that logic is executing properly, continue repeating this step until you find a line not working as expected, then move to step 3.
Fix the identified bug and run your code again. If it now works as expected, you've finished debugging! If not, continue stepping through your code using step 2 until it does.
This might seem like a lot of printing, but once you get into the routine of it, it will be far faster than trying to stare at your code until you find your bugs. Let's try this debugging process again in practice.

++++++++++++++++++++++++++++++++++++++
DEBUGGING JAVASCRIPT CODE
Finding Documentation

Sometimes once you've tracked down a bug, you might still be confused on how to fix it! Whenever you want to know more about how JavaScript works and what it can do, the best place to go is documentation. You can find the JavaScript documentation at the MDN JavaScript web docs.

The MDN JavaScript web docs are a powerful resource, but they can be overwhelming because they cover so much information. We encourage you to explore the docs, but often the fastest way to access a specific part of the docs you're interested in is to Google it.

For example, if we wanted more information on the Number object's .isNan() method, we could Google "MDN isNan" and then click the link to the MDN page. If we were looking to see a list of all of the String built-in methods, we might Google "MDN String", click the link to MDN, and then scroll down to the "Methods" section of the documentation.

There are many ways to get to the documentation you are looking for. Find the one that works best for your workflow.

+++++++++++++++++++++++++++++++++++++
DEBUGGING JAVASCRIPT CODE
Stack Overflow

At this point, you might be thinking to yourself, documentation is good and all, but there's no way it will solve all of my issues! And we totally agree. All programming languages have difficult problems and strange edge cases that appear unexpectedly and are sometimes impossible to solve alone.

If you are ever stuck trying to solve a coding problem, we strongly encourage you to Google for a solution. One of the best sites you will see appear in the search results is Stack Overflow.

Stack Overflow is a question and answer forum where frustrated programmers post issues and other programmers discuss and vote for solutions. Almost always if you have an issue, Stack Overflow has an answer.

For example, say you are stumped trying to write an alphabetize function. If you search "alphabetize string JavaScript" on Google, this Stack Overflow search result will appear. You can quickly scan through the answers on it to see which ones work for you.

If you are ever programming and a problem is becoming so insurmountable that you want to quit, Stack Overflow is a great place to go to get unstuck.

---------------------------------------------------------------
LEARN JAVASCRIPT: ERROR HANDLING
Introduction to Error Handling

There are two categories of programming mistakes: those that don't prevent our code from running and those that do.

Sometimes, we've written code that successfully returns a value but a different value from what we expected. Our program continues running, and we might not even realize anything went wrong until much later. It's like making soup and accidentally adding sugar instead of salt. In the end we still have soup, but it might not be soup that we want to eat. We will not be focusing on these mistakes.

Rather, we're going to focus on the errors that pop up when we've written code that causes our program to stop running, e.g. trying to reassign a const variable. Instead of returning anything, our program will not execute any more code past where the error occurred. For example, what if we tried to move our soup to the table but dropped it because it was too hot? Then our soup-making process is over— there would be no soup.

We can't always stop errors before they occur, but we can include a backup plan in our program to anticipate and respond to the errors to ensure that our program continues running. Error handling is the process of programmatically anticipating and addressing errors. In JavaScript, we handle errors using the keywords try and catch. We try to move the soup to the table, making sure there's someone or something nearby to catch the soup in case we drop it.

In this lesson we'll learn more about errors and how to create a backup plan to allow our program to continue running. When you're ready, let's try to get a handle on these JavaScript errors!

++++++++++++++++++++++++++++++++++++++++++++
LEARN JAVASCRIPT: ERROR HANDLING
Runtime Errors

Errors contain useful messages that that tell us why our program isn't working or why the error was thrown. When an error is thrown, our program stops running and the console displays red text of the error message like so:


When we execute code and a line of code throws an error, that error is referred to as a runtime error. In JavaScript, there are built-in errors objects that have a name and message property which tell us what when wrong. Examples of built-in runtime errors include:

ReferenceError: when a variable or function cannot be found.
TypeError: when a value is not a valid type, see the example below:
const reminder = 'Reduce, Reuse, Recycle';
reminder = 'Save the world';
// TypeError: Assignment to constant variable.
console.log('This will never be printed!');
In the example above, when we try to reassign a constant variable reminder, the TypeError is thrown. Code that is written after a thrown runtime error will not be evaluated, so the console.log() statement will not be evaluated.

Let's see for ourselves what happens when a runtime error is thrown.

++++++++++++++++++++++++++++++++++++++++++
LEARN JAVASCRIPT: ERROR HANDLING
Constructing an Error

JavaScript errors are objects that have a name and message property. Previously, we've seen how built-in errors alert us about common mistakes in our code. But, what if we need an error message that isn't covered by the built-in errors? Let's say we need to inform a user that a string passed in as an argument is too short with a custom message. Such a message isn't covered by a built-in error, but we could use the Error function to make our own error object with a message that is unique to our program!

console.log(Error('Your password is too weak.'));
// Prints: Error: Your password is too weak.
The Error function takes an argument of a string which becomes the value of the error's message property. In the code snippet above, we used the Error function to create an error object that has the message 'Your password is too weak.'.

You might also see errors created with the the new keyword. Both methods will lead to the same functionality. Take a look:

console.log(new Error('Your password is too weak.'));
// Prints: Error: Your password is too weak.
Keep in mind that creating an error is not the same as throwing an error. A thrown error will cause the program to stop running. We cover how to throw our created errors in the next exercise!

+++++++++++++++++++++++++++++++++
LEARN JAVASCRIPT: ERROR HANDLING
The throw Keyword

Creating an error doesn't cause our program to stop — remember, an error must be thrown for it to halt the program.

To throw an error in JavaScript, we use the throw keyword like so:

throw Error('Something wrong happened');
// Error: Something wrong happened
When we use the throw keyword, the error is thrown and code after throw statement will not execute. Take for example:

throw Error('Something wrong happened');
// Error: Something wrong happened

console.log('This will never run');
After throw Error('Something wrong happened'); is executed and the error object is thrown, the console.log() statement will not run (just like when a built-in JavaScript error was thrown!).

In the next lesson we will cover how to handle an error so that the rest of our code can run!

+++++++++++++++++++++++++++++++++++++++
LEARN JAVASCRIPT: ERROR HANDLING
The try...catch Statement

Up to this point, thrown errors have caused our program to stop running. But, we have the ability anticipate and handle these errors by writing code to address the error and allow our program to continue running.

In JavaScript, we use try...catch statement to anticipate and handle errors. Take a look at example below:

try {
  throw Error('This error will get caught');
} catch (e) {
  console.log(e);
}
// Prints: This error will get caught

console.log('The thrown error that was caught in the try...catch statement!');
// Prints: 'The thrown error that was caught in the try...catch statement!'
Now, let's break down what happened in the try...catch statement above:

We have code that follows try inside curly braces {} known as the try block.
Inside the try block we insert code that we anticipate might throw an error.
Since we want to see what happens if an error is thrown in the try block, we throw an error with the message 'This error will get caught'.
Following the try block is the catch statement which accepts the thrown error from the try block . The e represents the thrown error.
The curly braces that follow catch(e) is known as the catch block and contains code that executes to handle the error.
Since the error is caught, our console.log() after the try...catch statement prints 'The thrown error that was caught in the try...catch statement!'.
Generally speaking, in a try...catch statement, we evaluate code in the try block and if the code throws an error, the code inside the catch block will handle the error for us. The provided example just showcases how a try...catch statement works because we know an error is being thrown. Let's first practice writing our own try...catch statement and afterwards we will go over a more practical usage of try...catch.

+++++++++++++++++++++++++++++++++++++++++++++++
LEARN JAVASCRIPT: ERROR HANDLING
Handling with try...catch

In the previous exercise we caught an error that we threw, but we can also use a try...catch statement to handle built-in errors that are thrown by the JavaScript engine that is reading and evaluating our code.

const someVar = 'Cannot be reassigned';
try {
  someVar = 'Still going to try';
} catch(e) {
  console.log(e);
}
// Prints: TypeError: Assignment to constant variable.
In the example above, we didn't use the throw keyword to throw a custom error, rather we tried to re-assign a const variable and a TypeError was thrown. Then, in our catch block, we logged the error to the console.

Using a try...catch statement for built-in JavaScript errors is really beneficial when we need to use data from an external source that's not written directly in our program.

Let's say we expect to grab an array from a database but the information we get back is a string. In our program, we could have a function that only works on arrays. If that function was called with a string instead of an array we would get an error and our program would stop running!

However, we can use a try...catch statement to handle the thrown error for us which allows our program to continue running and we receive a message knowing what went wrong! Let's see how we can implement this in our code.

---------------------------------------------------------
09/01/2019

JAVASCRIPT PROMISES
Introduction

In web development, asynchronous programming is notorious for being a challenging topic.

An asynchronous operation is one that allows the computer to "move on" to other tasks while waiting for the asynchronous operation to complete. Asynchronous programming means that time-consuming operations don't have to bring everything else in our programs to a halt.

There are countless examples of asynchronicity in our everyday lives. Cleaning our house, for example, involves asynchronous operations such as a dishwasher washing our dishes or a washing machine washing our clothes. While we wait on the completion of those operations, we're free to do other chores.

Similarly, web development makes use of asynchronous operations. Operations like making a network request or querying a database can be time-consuming, but JavaScript allows us to execute other tasks while awaiting their completion.

This lesson will teach you how modern JavaScript handles asynchronicity using the Promise object, introduced with ES6. Let's get started!

+++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
What is a Promise?

Promises are objects that represent the eventual outcome of an asynchronous operation. A Promise object can be in one of three states:

Pending: The initial state— the operation has not completed yet.
Fulfilled: The operation has completed successfully and the promise now has a resolved value. For example, a request's promise might resolve with a JSON object as its value.
Rejected: The operation has failed and the promise has a reason for the failure. This reason is usually an Error of some kind.
We refer to a promise as settled if it is no longer pending— it is either fulfilled or rejected. Let's think of a dishwasher as having the states of a promise:

Pending: The dishwasher is running but has not completed the washing cycle.
Fulfilled: The dishwasher has completed the washing cycle and is full of clean dishes.
Rejected: The dishwasher encountered a problem (it didn't receive soap!) and returns unclean dishes.
If our dishwashing promise is fulfilled, we'll be able to perform related tasks, such as unloading the clean dishes from the dishwasher. If it's rejected, we can take alternate steps, such as running it again with soap or washing the dishes by hand.

All promises eventually settle, enabling us to write logic for what to do if the promise fulfills or if it rejects.

++++++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
Constructing a Promise Object

Let’s construct a promise! To create a new Promise object, we use the new keyword and the Promise constructor method:

const executorFunction = (resolve, reject) => { };
const myFirstPromise = new Promise(executorFunction);
The Promise constructor method takes a function parameter called the executor function which runs automatically when the constructor is called. The executor function generally starts an asynchronous operation and dictates how the promise should be settled.

The executor function has two function parameters, usually referred to as the resolve() and reject() functions. The resolve() and reject() functions aren't defined by the programmer. When the Promise constructor runs, JavaScript will pass its own resolve() and reject() functions into the executor function.

resolve is a function with one argument. Under the hood, if invoked, resolve() will change the promise's status from pending to fulfilled, and the promise's resolved value will be set to the argument passed into resolve().
reject is a function that takes a reason or error as an argument. Under the hood, if invoked, reject() will change the promise's status from pending to rejected, and the promise's rejection reason will be set to the argument passed into reject().
Let's look at an example executor function in a Promise constructor:

const executorFunction = (resolve, reject) => {
  if (someCondition) {
      resolve('I resolved!');
  } else {
      reject('I rejected!'); 
  }
}
const myFirstPromise = new Promise(executorFunction);
Let's break down what's happening above:

We declare a variable myFirstPromise
myFirstPromise is constructed using new Promise() which is the Promise constructor method.
executorFunction() is passed to the constructor and has two functions as parameters: resolve and reject.
If someCondition evaluates to true, we invoke resolve() with the string 'I resolved!'
If not, we invoke reject() with the string 'I rejected!'
In our example, myFirstPromise resolves or rejects based on a simple condition, but, in practice, promises settle based on the results of asynchronous operations. For example, a database request may fulfill with the data from a query or reject with an error thrown. In this exercise, we'll construct promises which resolve synchronously to more easily understand how they work.

1.
You'll be writing your code in the code-editor, but we won't be running it until the final step. To check your code for a step, you can press the "Check Work" button.

We're going to create a promise representing ordering sunglasses from an online store. First, create the function, myExecutor(). Later on, you'll pass this function into the Promise constructor.

myExecutor() should:

Have two parameters: resolve and reject
Check if the sunglasses property on the inventory object has a value greater than zero
If it does, myExecutor() should invoke resolve() with the string 'Sunglasses order processed.'
If it does not, myExecutor() should invoke reject() with the string 'That item is sold out.'
When you're ready, press the "Check Work" button.

2.
Create a function, orderSunglasses(). This function should have no parameters. It should return a new promise constructed by passing your myExecutor() function into the Promise constructor.

You'll need to use the new keyword and the Promise constructor method to create a new promise object:

new Promise(anExecutorFunction);
Remember to pass the function in without invoking it and make sure your orderSunglasses() function returns the promise.

3.
Create a variable orderPromise assigned to the returned value of your orderSunglasses() function.

4.
At the bottom of your app.js file, log orderPromise to the console.

5.const inventory = {
  sunglasses: 0,
  pants: 1088,
  bags: 1344
};

// Write your code below:
const myExecutor = (resolve, reject) => {
    if (inventory.sunglasses > 0) {
        resolve('Sunglasses order processed.');
    } else {
        reject('That item is sold out.');
    }
};

const orderSunglasses = () => {
    return new Promise(myExecutor);
};

const orderPromise = orderSunglasses();

console.log(orderPromise);                      
In this exercise and throughout the lesson, we'll provide you with a bash terminal to execute your code. To run the app.js program, you'll type node app.js in the terminal and hit enter (or return). You'll be able to see the output of the program in the terminal.

Let's try it! Type node app.js in the terminal and hit enter.

If you'd like, you can see an alternate output by changing the sunglasses property in the inventory object to 0 and executing app.js from the terminal again.

When you're ready to move on, press the "Check Work" button.

===================================================

const inventory = {
  sunglasses: 0,
  pants: 1088,
  bags: 1344
};

// Write your code below:
const myExecutor = (resolve, reject) => {
    if (inventory.sunglasses > 0) {
        resolve('Sunglasses order processed.');
    } else {
        reject('That item is sold out.');
    }
};

const orderSunglasses = () => {
    return new Promise(myExecutor);
};

const orderPromise = orderSunglasses();

console.log(orderPromise);                      

+++++++++++++++++++++++++++++++++++++++++++++++++++

JAVASCRIPT PROMISES
The Node setTimeout() Function

Knowing how to construct a promise is useful, but most of the time, knowing how to consume, or use, promises will be key. Rather than constructing promises, you'll be handling Promise objects returned to you as the result of an asynchronous operation. These promises will start off pending but settle eventually.

Moving forward, we'll be simulating this by providing you with functions that return promises which settle after some time. To accomplish this, we'll be using setTimeout(). setTimeout() is a Node API that uses callback functions to schedule tasks to be performed after a delay. setTimeout() has two parameters: a callback function and a delay in milliseconds.

const delayedHello = () => {
  console.log('Hi! This is an asynchronous greeting!');
};

setTimeout(delayedHello, 2000);
Here, we invoke setTimeout() with the callback function delayedHello() and 2000. In at least two seconds delayedHello() will be invoked. But why is it "at least" two seconds and not exactly two seconds?

This delay is performed asynchronously— the rest of our program won't stop executing during the delay. Asynchronous JavaScript uses something called the event-loop. After two seconds, delayedHello() is added to a line of code waiting to be run. Before it can run, any synchronous code from the program will run. Next, any code in front of it in the line will run. This means it might be more than two seconds before delayedHello() is actually executed.

Let's look at how we'll be using setTimeout() to construct asynchronous promises:

const returnPromiseFunction = () => {
  return new Promise((resolve, reject) => {
    setTimeout(( ) => {resolve('I resolved!')}, 1000);
  });
};

const prom = returnPromiseFunction();
In the example code, we invoked returnPromiseFunction() which returned a promise. We assigned that promise to the variable prom. Similar to the asynchronous promises you may encounter in production, prom will initially have a status of pending.

Let's explore setTimeout() a bit more.

Instructions
1.
Create a function, usingSTO(). Your usingSTO() function should have no parameters. Inside the function body, it should print a string to the console. This can be any string you want (as long as it's not either "This is the first line of synchronous code." or "This is the last line of synchronous code.").

Check your work to move on to the next step.

2.
Now, let's invoke the setTimeout() function. Remember, setTimeout() has two parameters. Invoke setTimeout() with your usingSTO() function as the first argument and a number between 0 and 3000 as the second argument.

3.
Take a moment to predict the output of this program.

Whenever you're ready, type node app.js in the terminal and hit enter.

See if the program's output in the terminal lines up with what you expected.

=========================================

console.log("This is the first line code in app.js.");
// Keep the line above as the first line of code
// Write your code here:
const usingSTO = ()=>{
  console.log("abc")
}

setTimeout(usingSTO, 3000);

// Keep the line below as the last line of code:
console.log("This is the last line of code in app.js.");

+++++++++++++++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
Consuming Promises

The initial state of an asynchronous promise is pending, but we have a guarantee that it will settle. How do we tell the computer what should happen then? Promise objects come with an aptly named .then() method. It allows us to say, "I have a promise, when it settles, then here's what I want to happen..."

In the case of our dishwasher promise, the dishwasher will run then:

If our promise rejects, this means we have dirty dishes, and we'll add soap and run the dishwasher again.
If our promise fulfills, this means we have clean dishes, and we'll put the dishes away.
.then() is a higher-order function— it takes two callback functions as arguments. We refer to these callbacks as handlers. When the promise settles, the appropriate handler will be invoked with that settled value.

The first handler, sometimes called onFulfilled, is a success handler, and it should contain the logic for the promise resolving.
The second handler, sometimes called onRejected, is a failure handler, and it should contain the logic for the promise rejecting.
We can invoke .then() with one, both, or neither handler! This allows for flexibility, but it can also make for tricky debugging. If the appropriate handler is not provided, instead of throwing an error, .then() will just return a promise with the same settled value as the promise it was called on. One important feature of .then() is that it always returns a promise. We'll return to this in more detail in a later exercise and explore why it's so important.

+++++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
The onFulfilled and onRejected Functions

To handle a "successful" promise, or a promise that resolved, we invoke .then() on the promise, passing in a success handler callback function:

const prom = new Promise((resolve, reject) => {
  resolve('Yay!');
});

const handleSuccess = (resolvedValue) => {
  console.log(resolvedValue);
};

prom.then(handleSuccess); // Prints: 'Yay!'
Let's break down what's happening in the example code:

prom is a promise which will resolve to 'Yay!'.
We define a function, handleSuccess(), which prints the argument passed to it.
We invoke prom's .then() function passing in our handleSuccess() function.
Since prom resolves, handleSuccess() is invoked with prom's resolved value, 'Yay', so 'Yay' is logged to the console.
With typical promise consumption, we won't know whether a promise will resolve or reject, so we'll need to provide the logic for either case. We can pass both an onFulfilled and onRejected callback to .then().

let prom = new Promise((resolve, reject) => {
  let num = Math.random();
  if (num < .5 ){
    resolve('Yay!');
  } else {
    reject('Ohhh noooo!');
  }
});

const handleSuccess = (resolvedValue) => {
  console.log(resolvedValue);
};

const handleFailure = (rejectionReason) => {
  console.log(rejectionReason);
};

prom.then(handleSuccess, handleFailure);
Let's break down what's happening in the example code:

prom is a promise which will randomly either resolve with 'Yay!'or reject with 'Ohhh noooo!'.
We pass two handler functions to .then(). The first will be invoked with 'Yay!' if the promise resolves, and the second will be invoked with 'Ohhh noooo!' if the promise rejects.
Let's write some onFulfilled and onRejected functions!

1.
Take a look at the provided code. We require in a function, checkInventory(). It builds on the logic of the orderSunglasses() function you wrote in a previous exercise.

checkInventory() takes in an array representing an order and returns a promise.
If every item in the order is in stock, that promise resolves with the value "Thank you. Your order was successful."
Otherwise, the promise rejects with the value "We're sorry. Your order could not be completed because some items are sold out".
We used setTimeout() to ensure that the checkInventory() promise settles asynchronously.

If you'd like, look at the library.js file to see how it works. Press "Check Work" when you're ready to move on.

2.
Write a function, handleSuccess(). You'll use this function later on as your success handler. handleSuccess() should have one parameter, representing a resolved value. Inside the body of handleSuccess(), log the parameter to the console.

3.
Write a function, handleFailure(). You'll use this function later on as your failure handler. handleFailure() should have one parameter, representing a rejection reason. Inside the body of handleFailure(), log the parameter to the console.

4.
Invoke checkInventory() with order. This will return a promise. Attach a .then() function to this. Pass into .then() the two handlers you wrote as callback functions.

5.
Type node app.js in the terminal and hit enter.
++++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
Using catch() with Promises

One way to write cleaner code is to follow a principle called separation of concerns. Separation of concerns means organizing code into distinct sections each handling a specific task. It enables us to quickly navigate our code and know where to look if something isn't working.

Remember, .then() will return a promise with the same settled value as the promise it was called on if no appropriate handler was provided. This implementation allows us to separate our resolved logic from our rejected logic. Instead of passing both handlers into one .then(), we can chain a second .then() with a failure handler to a first .then() with a success handler and both cases will be handled.

prom
  .then((resolvedValue) => {
    console.log(resolvedValue);
  })
  .then(null, (rejectionReason) => {
    console.log(rejectionReason);
  });
Since JavaScript doesn't mind whitespace, we follow a common convention of putting each part of this chain on a new line to make it easier to read. To create even more readable code, we can use a different promise function: .catch().

The .catch() function takes only one argument, onRejected. In the case of a rejected promise, this failure handler will be invoked with the reason for rejection. Using .catch() accomplishes the same thing as using a .then() with only a failure handler.

Let's look an example using .catch():

prom
  .then((resolvedValue) => {
    console.log(resolvedValue);
  })
  .catch((rejectionReason) => {
    console.log(rejectionReason);
  });
Let's break down what's happening in the example code:

prom is a promise which randomly either resolves with 'Yay!' or rejects with 'Ohhh noooo!'.
We pass a success handler to .then() and a failure handler to .catch().
If the promise resolves, .then()'s success handler will be invoked with 'Yay!'.
If the promise rejects, .then() will return a promise with the same rejection reason as the original promise and .catch()'s failure handler will be invoked with that rejection reason.
Let's practice writing .catch() functions.

1.
We're going to refactor the functionality of the previous exercise but this time we'll use .catch()! First invoke the checkInventory() function with the order. Remember, this function will return a promise.

2.
Add a .then() to the returned promise. Pass in the success handler handleSuccess().

3.
Add a .catch() to the returned promise. Pass in the failure handler handleFailure().

4.
We set our inventory of sunglasses to 0, so the order shouldn't go through. Let's make sure our code has the expected results. Type node app.js in the terminal and hit enter.

++++++++++++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
Chaining Multiple Promises

One common pattern we'll see with asynchronous programming is multiple operations which depend on each other to execute or that must be executed in a certain order. We might make one request to a database and use the data returned to us to make another request and so on! Let's illustrate this with another cleaning example, washing clothes:

We take our dirty clothes and put them in the washing machine. If the clothes are cleaned, then we'll want to put them in the dryer. After the dryer runs, if the clothes are dry, then we can fold them and put them away.

This process of chaining promises together is called composition. Promises are designed with composition in mind! Here's a simple promise chain in code:

firstPromiseFunction()
.then((firstResolveVal) => {
  return secondPromiseFunction(firstResolveVal);
})
.then((secondResolveVal) => {
  console.log(secondResolveVal);
});
Let's break down what's happening in the example:

We invoke a function firstPromiseFunction() which returns a promise.
We invoke .then() with an anonymous function as the success handler.
Inside the success handler we return a new promise— the result of invoking a second function, secondPromiseFunction() with the first promise's resolved value.
We invoke a second .then() to handle the logic for the second promise settling.
Inside that .then(), we have a success handler which will log the second promise's resolved value to the console.
In order for our chain to work properly, we had to return the promise secondPromiseFunction(firstResolveVal). This ensured that the return value of the first .then() was our second promise rather than the default return of a new promise with the same settled value as the initial.

Let's write some promise chains!

Instructions
1.
Take a look at the provided code. We require in three functions: checkInventory(), processPayment(), shipOrder(). These functions each return a promise.

checkInventory() expects an order argument and returns a promise. If there are enough items in stock to fill the order, the promise will resolve to an array. The first element in the resolved value array will be the same order and the second element will be the total cost of the order as a number.

processPayment() expects an array argument with the order as the first element and the purchase total as the second. This function returns a promise. If there is a large enough balance on the giftcard associated with the order, it will resolve to an array. The first element in the resolved value array will be the same order and the second element will be a tracking number.

shipOrder() expects an array argument with the order as the first element and a tracking number as the second. It returns a promise which resolves to a string confirming the order has shipped.

If you'd like, look at the library.js file to see how these functions work. Press "Check Work" when you're ready to move on to the next checkpoint.

2.
We set up a promise chain but it's missing a couple important lines of code to make it function properly.

We invoked checkInventory() with order and chained a .then() function to it. This .then() has an anonymous function as its success handler, but it's missing a return statement.

The success handler should return a processPayment() promise.

3.
We have a second .then() function on the chain. This .then() also has an anonymous function as its success handler and is missing a return statement.

The success handler should return a shipOrder() promise.

4.
Type node app.js in the terminal and hit enter.

===============================================
###app.js 

const {checkInventory, processPayment, shipOrder} = require('./library.js');

const order = {
  items: [['sunglasses', 1], ['bags', 2]],
  giftcardBalance: 79.82
};

checkInventory(order)
.then((resolvedValueArray) => {
  // Write the correct return statement here:
  return processPayment(resolvedValueArray);
 
})
.then((resolvedValueArray) => {
  // Write the correct return statement here:
  return shipOrder(resolvedValueArray);
  
})
.then((successMessage) => {
  console.log(successMessage);
})
.catch((errorMessage) => {
  console.log(errorMessage);
});


###library.js 

const store = {
  sunglasses: {
    inventory: 817, 
    cost: 9.99
  },
  pants: {
    inventory: 236, 
    cost: 7.99
  },
  bags: {
    inventory: 17, 
    cost: 12.99
  }
};

const checkInventory = (order) => {
  return new Promise ((resolve, reject) => {
   setTimeout(()=> {  
   const itemsArr = order.items;  
   let inStock = itemsArr.every(item => store[item[0]].inventory >= item[1]);
   
   if (inStock){
     let total = 0;   
     itemsArr.forEach(item => {
       total += item[1] * store[item[0]].cost
     });
     console.log(`All of the items are in stock. The total cost of the order is ${total}.`);
     resolve([order, total]);
   } else {
     reject(`The order could not be completed because some items are sold out.`);
   }     
}, generateRandomDelay());
 });
};

const processPayment = (responseArray) => {
  const order = responseArray[0];
  const total = responseArray[1];
  return new Promise ((resolve, reject) => {
   setTimeout(()=> {  
   let hasEnoughMoney = order.giftcardBalance >= total;
   // For simplicity we've omited a lot of functionality
   // If we were making more realistic code, we would want to update the giftcardBalance and the inventory
   if (hasEnoughMoney) {
     console.log(`Payment processed with giftcard. Generating shipping label.`);
     let trackingNum = generateTrackingNumber();
     resolve([order, trackingNum]);
   } else {
     reject(`Cannot process order: giftcard balance was insufficient.`);
   }
   
}, generateRandomDelay());
 });
};


const shipOrder = (responseArray) => {
  const order = responseArray[0];
  const trackingNum = responseArray[1];
  return new Promise ((resolve, reject) => {
   setTimeout(()=> {  
     resolve(`The order has been shipped. The tracking number is: ${trackingNum}.`);
}, generateRandomDelay());
 });
};


// This function generates a random number to serve as a "tracking number" on the shipping label. In real life this wouldn't be a random number
function generateTrackingNumber() {
  return Math.floor(Math.random() * 1000000);
}

// This function generates a random number to serve as delay in a setTimeout() since real asynchrnous operations take variable amounts of time
function generateRandomDelay() {
  return Math.floor(Math.random() * 2000);
}

module.exports = {checkInventory, processPayment, shipOrder};



++++++++++++++++++++++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
Avoiding Common Mistakes

Promise composition allows for much more readable code than the nested callback syntax that preceded it. However, it can still be easy to make mistakes. In this exercise, we'll go over two common mistakes with promise composition.

Mistake 1: Nesting promises instead of chaining them.

returnsFirstPromise()
.then((firstResolveVal) => {
  return returnsSecondValue(firstResolveVal)
    .then((secondResolveVal) => {
      console.log(secondResolveVal);
    })
})
Let's break down what's happening in the above code:

We invoke returnsFirstPromise() which returns a promise.
We invoke .then() with a success handler.
Inside the success handler, we invoke returnsSecondValue() with firstResolveVal which will return a new promise.
We invoke a second .then() to handle the logic for the second promise settling all inside the first then()!
Inside that second .then(), we have a success handler which will log the second promise's resolved value to the console.
Instead of having a clean chain of promises, we've nested the logic for one inside the logic of the other. Imagine if we were handling five or ten promises!

Mistake 2: Forgetting to return a promise.

returnsFirstPromise()
.then((firstResolveVal) => {
  returnsSecondValue(firstResolveVal)
})
.then((someVal) => {
  console.log(someVal);
})
Let's break down what's happening in the example:

We invoke returnsFirstPromise() which returns a promise.
We invoke .then() with a success handler.
Inside the success handler, we create our second promise, but we forget to return it!
We invoke a second .then(). It's supposed to handle the logic for the second promise, but since we didn't return, this .then() is invoked on a promise with the same settled value as the original promise!
Since forgetting to return our promise won't throw an error, this can be a really tricky thing to debug!

Instructions
1.
The code in app.js works correctly, but it doesn't follow best practices.

Type node app.js in the terminal and hit enter, so you can see what the program outputs.

2.
Refactor, or rewrite, the code to avoid the two common mistakes: nesting and forgetting to return properly.

3.
Type node app.js in the terminal and hit enter to make sure your program is still working as expected.

+++++++++++++++++++++++++++++++++++
JAVASCRIPT PROMISES
Using Promise.all()

When done correctly, promise composition is a great way to handle situations where asynchronous operations depend on each other or execution order matters. What if we're dealing with multiple promises, but we don't care about the order? Let's think in terms of cleaning again.

For us to consider our house clean, we need our clothes to dry, our trash bins emptied, and the dishwasher to run. We need all of these tasks to complete but not in any particular order. Furthermore, since they're all getting done asynchronously, they should really all be happening at the same time!

To maximize efficiency we should use concurrency, multiple asynchronous operations happening together. With promises, we can do this with the function Promise.all().

Promise.all() accepts an array of promises as its argument and returns a single promise. That single promise will settle in one of two ways:

If every promise in the argument array resolves, the single promise returned from Promise.all() will resolve with an array containing the resolve value from each promise in the argument array.
If any promise from the argument array rejects, the single promise returned from Promise.all() will immediately reject with the reason that promise rejected. This behavior is sometimes referred to as failing fast.
Let's look at a code example:

let myPromises = Promise.all([returnsPromOne(), returnsPromTwo(), returnsPromThree()]);

myPromises
  .then((arrayOfValues) => {
    console.log(arrayOfValues);
  })
  .catch((rejectionReason) => {
    console.log(rejectionReason);
  });
Let's break down what's happening:

We declare myPromises assigned to invoking Promise.all().
We invoke Promise.all() with an array of three promises— the returned values from functions.
We invoke .then() with a success handler which will print the array of resolved values if each promise resolves successfully.
We invoke .catch() with a failure handler which will print the first rejection message if any promise rejects.
Instructions
1.
Our business is doing so well that we're running low on inventory. We want to reach out to some distributors to see if they have the items we need. We only want to make one restocking order, so we'll only want to place the order if all of the items are available.

Take a look at the provided code. We require in one function: checkAvailability().

checkAvailability() expects two string arguments: an item and a distributor. It returns a promise. The function simulates checking that the given distributor has a given item. 80% of the time it will resolve the promise with the item, and 20% of the time it will reject the promise with an error message stating that the item isn't available.

We also provided two functions which will serve as success and failure handlers.

If you'd like, look at the library.js file to see how these functions work. Press "Check Work" when you're ready to move on to the next checkpoint.

2.
Create three variables each assigned to a separate promise:

checkSunglasses should be assigned the value returned from invoking checkAvailability() with 'sunglasses' as its first argument and 'Favorite Supply Co.' as its second argument.
checkPants should be assigned the value returned from invoking checkAvailability() with 'pants' as its first argument and 'Favorite Supply Co.' as its second argument.
checkBags should be assigned the value returned from invoking checkAvailability() with 'bags' as its first argument and 'Favorite Supply Co.' as its second argument.
3.
Invoke Promise.all() with an array containing checkSunglasses, checkPants, and checkBags.

4.
Chain a .then() to the promise returned from Promise.all(). You should pass in onFulfill to serve as the success handler.

5.
Add a .catch() to the chain. You should pass in onReject to serve as the failure handler.

6.
Type node app.js in the terminal and hit enter to execute your program.

==============================================
###app.js

const {checkAvailability} = require('./library.js');

const onFulfill = (itemsArray) => {
  console.log(`Items checked: ${itemsArray}`);
  console.log(`Every item was available from the distributor. Placing order now.`);
};

const onReject = (rejectionReason) => {
	console.log(rejectionReason);
};

// Write your code below:
const checkSunglasses = checkAvailability("sunglasses", "Favorite Supply Co.")

const checkPants = checkAvailability("pants", "Favorite Supply Co.")

const checkBags = checkAvailability("bags", "Favorite Supply Co.")

Promise.all([checkSunglasses,checkPants,checkBags])
.then(onFulfill)
.catch(onReject);


####library.js 

const checkAvailability = (itemName, distributorName) => {
    console.log(`Checking availability of ${itemName} at ${distributorName}...`);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (restockSuccess()) {
                console.log(`${itemName} are in stock at ${distributorName}`)
                resolve(itemName);
            } else {
                reject(`Error: ${itemName} is unavailable from ${distributorName} at this time.`);
            }
        }, 1000);
    });
};

module.exports = { checkAvailability };


// This is a function that returns true 80% of the time
// We're using it to simulate a request to the distributor being successful this often
function restockSuccess() {
    return (Math.random() > .2);
}

----------------------------------------------------------------------
09/01/2019

ASYNC AWAIT
Introduction

Often in web development, we need to handle asynchronous actions— actions we can wait on while moving on to other tasks. We make requests to networks, databases, or any number of similar operations. JavaScript is non-blocking: instead of stopping the execution of code while it waits, JavaScript uses an event-loop which allows it to efficiently execute other tasks while it awaits the completion of these asynchronous actions.

Originally, JavaScript used callback functions to handle asynchronous actions. The problem with callbacks is that they encourage complexly nested code which quickly becomes difficult to read, debug, and scale. With ES6, JavaScript integrated native promises which allow us to write significantly more readable code. JavaScript is continually improving, and ES8 provides a new syntax for handling our asynchronous action, async...await. The async...await syntax allows us to write asynchronous code that reads similarly to traditional synchronous, imperative programs.

The async...await syntax is syntactic sugar— it doesn't introduce new functionality into the language, but rather introduces a new syntax for using promises and generators. Both of these were already built in to the language. Despite this, async...await powerfully improves the readability and scalability of our code. Let's learn how to use it!

Instructions
1.
In this lesson, you'll be given a code-editor to write your code and a bash terminal to execute your code. To execute your program, you'll type node app.js in the terminal and hit enter (or return). You'll press the "Check Work" button to submit your code for evaluation.

Check out the code we provided. It shows three ways of accomplishing the same task: reading and printing from two files in a specified order:

The first version uses callback functions.
The second version uses native promise syntax
The third version uses async...await.
Don't worry about understanding the async...await syntax— that's what you'll learn in this lesson! If you haven't already, type node app.js into the terminal and press enter. Then, press "Check Work".

=========================================
const fs = require('fs');
const promisifiedReadfile = require('./promisifiedReadfile');
      
// Here we use fs.readfile() and callback functions:
fs.readFile('./file.txt', 'utf-8', (err, data) => {
  if (err) throw err;
  let firstSentence = data;
  fs.readFile('./file2.txt',  'utf-8', (err, data) => {
    if (err) throw err;
    let secondSentence = data;
    console.log(firstSentence, secondSentence)
  });
});

// Here we use native promises with our "promisified" version of readfile:
let firstSentence
promisifiedReadfile('./file.txt', 'utf-8')
  .then((data) => {
    firstSentence = data;
    return promisifiedReadfile('./file2.txt', 'utf-8')
  })
  .then((data) => {
    let secondSentence = data;
    console.log(firstSentence, secondSentence)
  })
  .catch((err) => {console.log(err)});

// Here we use promisifiedReadfile() again but instead of using the native promise .then() syntax, we declare and invoke an async/await function:
async function readFiles() {
  let firstSentence = await promisifiedReadfile('./file.txt', 'utf-8')
  let secondSentence = await promisifiedReadfile('./file2.txt', 'utf-8')
  console.log(firstSentence, secondSentence)
}
readFiles()

++++++++++++++++++++++++++++++++++++++++++
ASYNC AWAIT
The async Keyword

The async keyword is used to write functions that handle asynchronous actions. We wrap our asynchronous logic inside a function prepended with the async keyword. Then, we invoke that function.

async function myFunc() {
  // Function body here
};

myFunc();
We'll be using async function declarations throughout this lesson, but we can also create async function expressions:

const myFunc = async () => {
  // Function body here
};

myFunc();
async functions always return a promise. This means we can use traditional promise syntax, like .then() and .catch with our async functions. An async function will return in one of three ways:

If there's nothing returned from the function, it will return a promise with a resolved value of undefined.
If there's a non-promise value returned from the function, it will return a promise resolved to that value.
If a promise is returned from the function, it will simply return that promise
async function fivePromise() { 
  return 5;
}

fivePromise()
.then(resolvedValue => {
    console.log(resolvedValue);
  })  // Prints 5
In the example above, even though we return 5 inside the function body, what's actually returned when we invoke fivePromise() is a promise with a resolved value of 5.

Let's write an async function!

1.
We provided a function withConstructor() which takes in a number. If the number is 0, it returns a promise that resolves to the string 'zero'. If the number is not 0, it returns a promise that resolves to the string 'not zero'. Take a moment to understand this function and the code that follows. When you're ready to run it, type node app.js in to the terminal and press enter.

2.
Write an async function, withAsync() which reproduces the functionality of withConstructor(). Though your function will return a promise, it should not construct the promise using the new keyword. Instead, it should rely on the fact that an async function automatically returns a promise.

When you're ready, check your work to move on to the next step.

3.
Now test your code! Uncomment the test code we wrote at the bottom of app.js. In the terminal type node app.js and press enter to execute the code.

=======================================

function withConstructor(num){
  return new Promise((resolve, reject) => {
    if (num === 0){
      resolve('zero');
    } else {
      resolve('not zero');
    }
  })
}

withConstructor(0)
  .then((resolveValue) => {
  console.log(` withConstructor(0) returned a promise which resolved to: ${resolveValue}.`);
})

// Write your code below:
async function withAsync(num){
  if (num===0){
    return('zero')
  } else {
    return ('not zero')
  }
}

// Leave this commented out until step 3:
withAsync(100)
  .then((resolveValue) => {
  console.log(` withAsync(100) returned a promise which resolved to: ${resolveValue}.`);
})

++++++++++++++++++++++++++++++++++++++++
ASYNC AWAIT
The await Operator

In the last exercise, we covered the async keyword. By itself, it doesn't do much; async functions are almost always used with the additional keyword await inside the function body.

The await keyword can only be used inside an async function. await is an operator: it returns the resolved value of a promise. Since promises resolve in an indeterminate amount of time, await halts, or pauses, the execution of our async function until a given promise is resolved.

In most situations, we're dealing with promises that were returned from functions. Generally, these functions are through a library, and, in this lesson, we'll be providing them. We can await the resolution of the promise it returns inside an async function. In the example below, myPromise() is a function that returns a promise which will resolve to the string "I am resolved now!".

async function asyncFuncExample(){
  let resolvedValue = await myPromise();
  console.log(resolvedValue);
}

asyncFuncExample(); // Prints: I am resolved now!
Within our async function, asyncFuncExample(), we use await to halt our execution until myPromise() is resolved and assign its resolved value to the variable resolvedValue. Then we log resolvedValue to the console. We're able to handle the logic for a promise in a way that reads like synchronous code.

Instructions
1.
In the provided code, we've required in the function brainstormDinner(). This function expects no arguments and returns a new promise with a resolved value of a string representing a meal. (You can look at the code for this function by navigating to the library.js file.)

Look at the nativePromiseDinner() function in app.js. Take a moment to understand this function and predict its expected outcome. In the next step, you'll be recreating its functionality using async...await rather than native promises.

It's not necessary to execute the nativePromiseDinner() function, but, if you'd like to, check out the hint for some guidance. Press "Check Work" when you're ready to move on to the next step.

2.
Fill in the body of the announceDinner() function so that it has the same functionality as nativePromiseDinner(). It should wait for the promise returned from brainstormDinner() to resolve, and then log a string to the console in the same format as did nativePromiseDinner(). You'll need to use the await operator inside your function.

When you're ready, check your work to move on to the next step.

3.
At the bottom of app.js, beneath the function declaration, invoke the announceDinner() function.

4.
In the terminal type node app.js and press enter to execute your code.

==================================

#app.js 

const brainstormDinner = require('./library.js')


// Native promise version:
function nativePromiseDinner() {
  brainstormDinner().then((meal) => {
	  console.log(`I'm going to make ${meal} for dinner.`);
  })
}

nativePromiseDinner();

// async/await version:
async function announceDinner() {
  // Write your code below:
  let meal = await brainstormDinner()
  console.log(`I'm going to make ${meal} for dinner.`);
}

announceDinner();

#library.js 

/*
this is the brainstormDinner function. It's a little silly. It returns a promise that uses a series of setTimeout() functions to simulate a time-consuming asynchronous action. It's a good example of "callback hell" or "the pyramid of doom," two ways people describe how confusing a bunch of nested callback functions can become.
*/

const brainstormDinner = () => {
  return new Promise((resolve, reject) => {
  console.log(`I have to decide what's for dinner...`)
  setTimeout(() => {
    console.log('Should I make salad...?')
    setTimeout(() => {
      console.log('Should I make ramen...?')
      setTimeout(() => {
        console.log('Should I make eggs...?')
        setTimeout(() => {
          console.log('Should I make chicken...?')
          resolve('beans')
        }, 1000)
      }, 1000)
    }, 1000)
  }, 1000)
})
}

module.exports = brainstormDinner


+++++++++++++++++++++++++++++++++++++++++++++++++++
ASYNC AWAIT
Writing async Functions

We've seen that the await keyword halts the execution of an async function until a promise is no longer pending. Don't forget the await keyword! It may seem obvious, but this can be a tricky mistake to catch because our function will still run— it just won't have the desired results.

We're going to explore this using the following function, which returns a promise that resolves to 'Yay, I resolved!' after a 1 second delay:

let myPromise = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Yay, I resolved!')
    }, 1000);
  });
}
Now we'll write two async functions which invoke myPromise():

async function noAwait() {
 let value = myPromise();
 console.log(value);
}

async function yesAwait() {
 let value = await myPromise();
 console.log(value);
}

noAwait(); // Prints: Promise { <pending> }
yesAwait(); // Prints: Yay, I resolved!
In the first async function, noAwait(), we left off the await keyword before myPromise(). In the second, yesAwait(), we included it. The noAwait() function logs Promise { <pending> } to the console. Without the await keyword, the function execution wasn't paused. The console.log() on the following line was executed before the promise had resolved.

Remember that the await operator returns the resolved value of a promise. When used properly in yesAwait(), the variable value was assigned the resolved value of the myPromise() promise, whereas in noAwait(), value was assigned the promise object itself.

Instructions
1.
Take a look at the provided code. We required in the shopForBeans() function from library.js which returns a promise with a resolved value of a string representing a type of bean, eg. 'kidney'.

Next, we declared the getBeans() function. Let's summarize its intended functionality:

Log '1. Heading to the store to buy beans...' to the console.
Capture the resolved value of the promise returned when we invoke shopForBeans().
The promise returned from shopForBeans() prints a string in the format '2. I bought [the resolved type of beans] beans because they were on sale.'
Finally, the function prints a string in the format '3. Great! I'm making [the bean type] beans for dinner tonight!' to the console.
Execute app.js in the terminal to see if getBeans() is working as intended.

2.
Uh oh, getBeans() is logging '3. Great! I'm making [object Promise] beans for dinner tonight!' to the console. Take a moment to understand why this is happening, and then refactor getBeans() so it works as intended. Check your work when you're ready to move on to the next step.

3.
To test that the code is now functioning properly, execute app.js in the terminal again.

+++++++++++++++++++++++++++++++++++++++++++++++
ASYNC AWAIT
Handling Dependent Promises
The true beauty of async...await is when we have a series of asynchronous actions which depend on one another. For example, we may make a network request based on a query to a database. In that case, we would need to wait to make the network request until we had the results from the database. With native promise syntax, we use a chain of .then() functions making sure to return correctly each one:

function nativePromiseVersion() {
    returnsFirstPromise()
    .then((firstValue) => {
        console.log(firstValue);
        return returnsSecondPromise(firstValue);
    })
   .then((secondValue) => {
        console.log(secondValue);
    });
}
Let's break down what's happening in the nativePromiseVersion() function:

Within our function we use two functions which return promises: returnsFirstPromise() and returnsSecondPromise().
We invoke returnsFirstPromise() and ensure that the first promise resolved by using .then().
In the callback of our first .then(), we log the resolved value of the first promise, firstValue, and then return returnsSecondPromise(firstValue).
We use another .then() to print the second promise's resolved value to the console.
Here's how we'd write an async function to accomplish the same thing:

async function asyncAwaitVersion() {
 let firstValue = await returnsFirstPromise();
 console.log(firstValue);
 let secondValue = await returnsSecondPromise(firstValue);
 console.log(secondValue);
}
Let's break down what's happening in our asyncAwaitVersion() function:

We mark our function as async.
Inside our function, we create a variable firstValue assigned await returnsFirstPromise(). This means firstValue is assigned the resolved value of the awaited promise.
Next, we log firstValue to the console.
Then, we create a variable secondValue assigned to await returnsSecondPromise(firstValue). Therefore, secondValue is assigned this promise's resolved value.
Finally, we log secondValue to the console.
Though using the async...await syntax can save us some typing, the length reduction isn't the main point. Given the two versions of the function, the async...await version more closely resembles synchronous code, which helps developers maintain and debug their code. The async...await syntax also makes it easy to store and refer to resolved values from promises further back in our chain which is a much more difficult task with native promise syntax. Let's create some async functions with multiple await statements!

Instructions
1.
Take a look at the provided code. We require in three functions: shopForBeans(), soakTheBeans(), and cookTheBeans(). These functions each return a promise.

shopForBeans() expects no arguments and returns a promise which will resolve to a string of a bean type.
soakTheBeans() expects a bean type string as an argument and returns a promise which resolves to a boolean indicating whether or not the beans are softened.
cookTheBeans() expects a boolean as an argument and, if that value is true, returns a promise which will resolve to a string announcing that dinner is ready.
If you'd like, look at the library.js file to see how these functions work. Press "Check Work" to move on to the next step.

2.
In the following checkpoints, you'll create an async function that handles the three dependent promises we just walked through. It will simulate shopping for, soaking, and then cooking the beans. To get started, declare an async function, makeBeans(). You can leave the function body blank for now.

Check your work to move on to the next step.

3.
Inside your function, declare a variable, type, assigned to the resolved value of shopForBeans(). This must be accomplished in one statement.

4.
Next inside your function, declare a variable, isSoft, assigned to the resolved value of soakTheBeans(). Don't forget: the soakTheBeans() function expects an argument. Make sure to pass the expected value into soakTheBeans().

5.
Next inside your function, declare a variable, dinner, assigned to the resolved of cookTheBeans(). Don't forget: the cookTheBeans() function also expects an argument. Make sure to pass the expected value into cookTheBeans().

6.
Next inside your function, log your dinner variable to the console.

7.
Beneath your function declaration, invoke the makeBeans() function.

8.
Let's see your async function in action! In the terminal, type node app.js and press enter to execute the code.

=======================================

#app.js 
const {shopForBeans, soakTheBeans, cookTheBeans} = require('./library.js');

// Write your code below:
async function makeBeans(){
  let type = await shopForBeans();
  let isSoft = await soakTheBeans(type);
  let dinner = await cookTheBeans(isSoft);
  console.log(dinner);
}
makeBeans();


===================================
# library.js 

/*
This is the shopForBeans function from the last exercise
*/

const shopForBeans = () => {
  return new Promise((resolve, reject) => {
	const beanTypes = ['kidney', 'fava', 'pinto', 'black', 'garbanzo'];
  setTimeout(()=>{
    let randomIndex = Math.floor(Math.random() * 5)
    let beanType = beanTypes[randomIndex];
    console.log(`I bought ${beanType} beans because they were on sale.`)
   resolve(beanType);
  }, 1000)
})
}

let soakTheBeans = (beanType) => {
   return new Promise((resolve, reject) => {
     console.log('Time to soak the beans.')
    setTimeout(()=>{
      console.log(`... The ${beanType} beans are softened.`)
      resolve(true)
      }, 1000)
  })
}

let cookTheBeans = (isSoftened) => {
  return new Promise((resolve, reject) => {
    console.log('Time to cook the beans.')
    setTimeout(()=>{
      if (isSoftened) {
        console.log('... The beans are cooked!') 
        resolve('\n\nDinner is served!')
      }
    }, 1000)
  })
}

  
module.exports = {shopForBeans, soakTheBeans, cookTheBeans} 

++++++++++++++++++++++++++++++++++++++++
ASYNC AWAIT
Handling Errors


When .catch() is used with a long promise chain, there is no indication of where in the chain the error was thrown. This can make debugging challenging.

With async...await, we use try...catch statements for error handling. By using this syntax, not only are we able to handle errors in the same way we do with synchronous code, but we can also catch both synchronous and asynchronous errors. This makes for easier debugging!

async function usingTryCatch() {
 try {
   let resolveValue = await asyncFunction('thing that will fail');
   let secondValue = await secondAsyncFunction(resolveValue);
 } catch (err) {
   // Catches any errors in the try block
   console.log(err);
 }
}

usingTryCatch();
Remember, since async functions return promises we can still use native promise's .catch() with an async function

async function usingPromiseCatch() {
   let resolveValue = await asyncFunction('thing that will fail');
}

let rejectedPromise = usingPromiseCatch();
rejectedPromise.catch((rejectValue) => {
console.log(rejectValue);
})
This is sometimes used in the global scope to catch final errors in complex code.

Instructions
1.
For convenience, we've been working with a lot of promises that never reject, but this isn't very realistic!

This time we've required in a function, cookBeanSouffle() which returns a promise that resolves or rejects randomly. When it resolves, the promise resolves with a value of 'Bean Souffle' and, when it rejects, it rejects with a value of 'Dinner is ruined!'. If you're interested, you can see how the function works by looking in the library.js file.

Press "Check Work" when you're ready to move on to the next step.

2.
Declare an async function, hostDinnerParty(). Inside your function, create a try...catch statement. The catch statement should specify an identifier, error. You can leave both the try and catch blocks empty.

3.
Inside your try block, log a string in the following format: '[resolved value of cookBeanSouffle() promise] is served!' ie. 'Bean Souffle is served!'. Make sure to await the cookBeanSouffle() promise. For more guidance, check out the hint.

4.
Now let's fill in the catch block! First log the error to the console, and then log the string: 'Ordering a pizza!' to the console.

5.
Awesome! Beneath your function declaration, invoke hostDinnerParty().

6.
Let's see your function in action. In the terminal type node app.js and press enter to run the code. If you keep executing app.js you'll see the results of the promise resolving or rejecting.

==================================
#app.js  
const cookBeanSouffle = require('./library.js');

// Write your code below:
async function hostDinnerParty(){
  try {
    let firstResolvedValue = await cookBeanSouffle();
    console.log(`${firstResolvedValue} is served!`);
    
  }catch(err){
    console.log(err);
    console.log('Ordering a pizza!');
  }
}
hostDinnerParty();

===================================
//This function returns true 50% of the time.
let randomSuccess = () => {
 let num = Math.random();
 if (num < .5 ){
   return true;
 } else {
   return false;
 }
};

//This function returns a promise that resolves half of the time and rejects half of the time
let cookBeanSouffle = () => {
 return new Promise((resolve, reject) => {
   console.log('Fingers crossed... Putting the Bean Souffle in the oven');
   setTimeout(()=>{
     let success = randomSuccess();
     if(success){
       resolve('Bean Souffle');
     } else {
       reject('Dinner is ruined!');
     }
   }, 1000);
 })
};

module.exports = cookBeanSouffle;

---------------------------------------
ASYNC AWAIT
Handling Independent Promises
Remember that await halts the execution of our async function. This allows us to conveniently write synchronous-style code to handle dependent promises. But what if our async function contains multiple promises which are not dependent on the results of one another to execute?

async function waiting() {
 const firstValue = await firstAsyncThing();
 const secondValue = await secondAsyncThing();
 console.log(firstValue, secondValue);
}

async function concurrent() {
 const firstPromise = firstAsyncThing();
 const secondPromise = secondAsyncThing();
console.log(await firstPromise, await secondPromise);
}
In the waiting() function, we pause our function until the first promise resolves, then we construct the second promise. Once that resolves, we print both resolved values to the console.

In our concurrent() function, both promises are constructed without using await. We then await each of their resolutions to print them to the console.

With our concurrent() function both promises' asynchronous operations can be run simultaneously. If possible, we want to get started on each asynchronous operation as soon as possible! Within our async functions we should still take advantage of concurrency, the ability to perform asynchronous actions at the same time.

Note: if we have multiple truly independent promises that we would like to execute fully in parallel, we must use individual .then() functions and avoid halting our execution with await.

Instructions
1.
Take a look at the provided code. We require in four functions: cookBeans(), steamBroccoli(), cookRice(), and bakeChicken(). These functions each return a promise which will resolve to a string representing a part of a meal.

If you'd like, look at the library.js file to see how these functions work. Press "Check Work" when you're ready to move on.

2.
Declare an async function, serveDinner(). Create four variables:

vegetablePromise which should be assigned the return value of steamBroccoli()
starchPromise which should be assigned the return value of cookRice()
proteinPromise which should be assigned the return value of bakeChicken()
and sidePromise which should be assigned the return value of cookBeans()
These variables should be assigned the promise objects themselves not their resolved values.

3.
Next console.log() a string in the following format: Dinner is served. We're having [resolved value of the vegetablePromise], [resolved value of the starchPromise], [resolved value of the proteinPromise], and [resolved value of the sidePromise]. ie. 'Dinner is served. We're having broccoli, rice, chicken, and beans.'

You'll need to await each promise, but there are a few different ways you can accomplish the desired functionality. Check out the hint if you want some guidance.

4.
Awesome! Let's see your function in action. Beneath your function declaration, invoke serveDinner().

5.
In the terminal type node app.js and press enter to run the code.

==========================
#app.js 

let {cookBeans, steamBroccoli, cookRice, bakeChicken} = require('./library.js')

// Write your code below:

async function serveDinner() {
 let vegetablePromise = steamBroccoli();
 let starchPromise = cookRice();
 let proteinPromise = bakeChicken();
 let sidePromise = cookBeans();
 console.log(`Dinner is served. We're having ${await vegetablePromise}, ${await starchPromise}, ${await proteinPromise}, and ${await sidePromise}.`)
}

serveDinner()

======================
#library.js 

let cookBeans = () => {
  return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('beans')
   }, 1000)
 })
}

let steamBroccoli = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('broccoli')
   }, 1000)
 })
}

let cookRice = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('rice')
   }, 1000)
 })
}

let bakeChicken = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('chicken')
   }, 1000)
 })
}

module.exports = {cookBeans, steamBroccoli, cookRice, bakeChicken}

--------------------------------------------------------

ASYNC AWAIT
Await Promise.all()

Another way to take advantage of concurrency when we have multiple promises which can be executed simultaneously is to await a Promise.all().

We can pass an array of promises as the argument to Promise.all(), and it will return a single promise. This promise will resolve when all of the promises in the argument array have resolved. This promise's resolve value will be an array containing the resolved values of each promise from the argument array.

async function asyncPromAll() {
  const resultArray = await Promise.all([asyncTask1(), asyncTask2(), asyncTask3(), asyncTask4()]);
  for (let i = 0; i<resultArray.length; i++){
    console.log(resultArray[i]); 
  }
}
In our above example, we await the resolution of a Promise.all(). This Promise.all() was invoked with an argument array containing four promises (returned from required-in functions). Next, we loop through our resultArray, and log each item to the console. The first element in resultArray is the resolved value of the asyncTask1() promise, the second is the value of the asyncTask2() promise, and so on.

Promise.all() allows us to take advantage of asynchronicity— each of the four asynchronous tasks can process concurrently. Promise.all() also has the benefit of failing fast, meaning it won't wait for the rest of the asynchronous actions to complete once any one has rejected. As soon as the first promise in the array rejects, the promise returned from Promise.all() will reject with that reason. As it was when working with native promises, Promise.all() is a good choice if multiple asynchronous tasks are all required, but none must wait for any other before executing.

=====================
#app.js 

let {cookBeans, steamBroccoli, cookRice, bakeChicken} = require('./library.js')

// Write your code below:
async function  serveDinnerAgain(){
  let foodArray = await Promise.all([steamBroccoli(), cookRice(), bakeChicken(), cookBeans()])
  let vegetable = foodArray[0];
  let starch =  foodArray[1];
  let protein =  foodArray[2];
  let side =  foodArray[3];

  console.log(`Dinner is served. We're having ${vegetable}, ${starch}, ${protein}, and ${side}.`);
  
}

serveDinnerAgain();

------------------------------------------
10/01/2019 

REQUESTS I

#main.js 

// NOTE: wordSmith functions from lines 4 - 39
// NOTE: byteSize functions from lines 41 - 76 (remember to add your API key!)

// information to reach API
const dataMuseUrl = 'https://api.datamuse.com/words?';
const queryParams = 'rel_jjb=';

// selecting page elements
const inputField = document.querySelector('#input');
const submit = document.querySelector('#submit');
const responseField = document.querySelector('#responseField');

// AJAX function
const getSuggestions = () => {
  const wordQuery = inputField.value;
  const endPoint = dataMuseUrl + queryParams + wordQuery;

  const xhr = new XMLHttpRequest();
  xhr.responseType = 'json';

  xhr.onreadystatechange = () => {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      renderWordResponse(xhr.response);
    }
  };
  xhr.open('GET', endPoint);
  xhr.send();
}

// clear previous results and display results to webpage
const displaySuggestions = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  };
  getSuggestions();
};

submit.addEventListener('click', displaySuggestions);

// information to reach Rebrandly API
const apiKey = 'b3e68237f76c493ea4386c03e6db44e6';
const rebrandlyUrl = 'https://api.rebrandly.com/v1/links';

// element selector
const shortenButton = document.querySelector('#shorten');

// AJAX functions
const shortenUrl = () => {
  const urlToShorten = inputField.value;
  const data = JSON.stringify({destination: urlToShorten});

  const xhr = new XMLHttpRequest();
  xhr.responseType = 'json';

  xhr.onreadystatechange = () => {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      renderByteResponse(xhr.response);
    }
  };
  xhr.open('POST', rebrandlyUrl);
  xhr.setRequestHeader('Content-type', 'application/json');
	xhr.setRequestHeader('apikey', apiKey);
  xhr.send(data);
}

// Clear page and call AJAX functions
const displayShortUrl = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  };
  shortenUrl();
};

shortenButton.addEventListener('click', displayShortUrl);

++++++++++++++++++++++++++++++++++
REQUESTS II 

#main.js 

// NOTE: wordSmith functions from lines 4 - 39
// NOTE: byteSize functions from lines 48 - 81 (remember to add your API key!)

// information to reach API
const dataMuseUrl = 'https://api.datamuse.com/words?';
const queryParams = 'rel_jjb=';

// selecting page elements
const inputField = document.querySelector('#input');
const submit = document.querySelector('#submit');
const responseField = document.querySelector('#responseField');

// AJAX function
const getSuggestions = async () => {
  const wordQuery = inputField.value;
  const endpoint = dataMuseUrl + queryParams + wordQuery;

  try{
    const response =  await fetch(endpoint);
    if(response.ok){
      let jsonResponse = await response.json();
			renderWordResponse(jsonResponse);
    }
  }
  catch(error){
    console.log(error);
  }
}

// clear previous results and display results to webpage
const displaySuggestions = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  }
  getSuggestions();
}

submit.addEventListener('click', displaySuggestions);

// information to reach Rebrandly API
const apiKey = 'b3e68237f76c493ea4386c03e6db44e6
';
const rebrandlyEndpoint = 'https://api.rebrandly.com/v1/links';

// element selector
const shortenButton = document.querySelector('#shorten');

// AJAX functions
const shortenUrl = async () =>{
  const urlToShorten = inputField.value;
  const data = JSON.stringify({destination: urlToShorten});

  try{
    const response =  await fetch(rebrandlyEndpoint, {
      method: 'POST',
      body: data,
      headers: {
        "Content-type": "application/json",
        'apikey': apiKey
      }
    })
    if(response.ok){
      const jsonResponse = await response.json();
			renderByteResponse(jsonResponse);
    }
  }
  catch(error){
    console.log(error);
  }
}

// Clear page and call AJAX functions
const displayShortUrl = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  }
  shortenUrl();
}

shortenButton.addEventListener('click', displayShortUrl);

=============================
#helperFunctions.js 

// wordSmith helperFunctions are on lines 4 - 50
// byteSize helperFunctions are on lines 52 - 76

// Formats Response to look presentable on webpage
const renderWordResponse = (res) => {
  // Handles if res is falsey
  if(!res){
    console.log(res.status);
  }
  // In case res comes back as a blank array
  if(!res.length){
    responseField.innerHTML = "<p>Try again!</p><p>There were no suggestions found!</p>";
    return;
  }

  // Creates an array to contain the HTML strings
  let wordList = []
  // Loops through the response and maxxing out at 10
  for(let i = 0; i < Math.min(res.length, 10); i++){
    // Creates a list of words
    wordList.push(`<li>${res[i].word}</li>`);
  }
  // Joins the array of HTML strings into one string
  wordList = wordList.join("");

  // Manipulates responseField to render the modified response
  responseField.innerHTML = `<p>You might be interested in:</p><ol>${wordList}</ol>`;
  return;
}

// Renders response before it is modified
const renderRawWordResponse = (res) => {
  // Takes the first 10 words from res
  let trimmedResponse = res.slice(0, 10);
  // Manipulates responseField to render the unformatted response
  responseField.innerHTML = `<text>${JSON.stringify(trimmedResponse)}</text>`;
}

// Renders the JSON that was returned when the Promise from fetch resolves.
const renderJsonWordResponse = (res) => {
  // Creating an empty object to store the JSON in key-value pairs
  let rawJson = {};
  for(let key in response){
    rawJson[key] = response[key];
  }
  // Converting JSON into a string and adding line breaks to make it easier to read
  rawJson = JSON.stringify(rawJson).replace(/,/g, ", \n");
  // Manipulates responseField to show the returned JSON.
  responseField.innerHTML = `<pre>${rawJson}</pre>`;
}

// Manipulates responseField to render a formatted and appropriate message
const renderByteResponse = (res) => {
  if(res.errors){
    // Will change the HTML to show this error message if the response had an error
    responseField.innerHTML = "<p>Sorry, couldn't format your URL.</p><p>Try again.</p>";
  } else {
    // If there was no error, then the HTML will show this message
    responseField.innerHTML = `<p>Your shortened url is: </p><p> ${res.shortUrl} </p>`;
  }
}

// Manipulates responseField to render an unformatted response
const renderRawByteResponse = (res) => {
  if(res.errors){
    // Changes the HTML to show this error message if the response had an error
    responseField.innerHTML = "<p>Sorry, couldn't format your URL.</p><p>Try again.</p>";
  } else {
    // Changes the HTML to show this raw response if there was no error
    // Formats the response into a more organized structure
    let structuredRes = JSON.stringify(res).replace(/,/g, ", \n");
    structuredRes = `<pre>${structuredRes}</pre>`;

    responseField.innerHTML = `${structuredRes}`;
  }
}

------------------------------------------------------











